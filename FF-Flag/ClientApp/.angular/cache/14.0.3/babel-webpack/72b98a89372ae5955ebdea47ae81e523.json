{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\nimport { logger } from \"./log\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\n\nexport class ServiceClient {\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options = {}) {\n    var _a, _b;\n\n    this._requestContentType = options.requestContentType;\n    this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n\n    if (options.baseUri) {\n      logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n    }\n\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n\n    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n      for (const {\n        policy,\n        position\n      } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase\n        });\n      }\n    }\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n\n\n  sendRequest(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.pipeline.sendRequest(_this._httpClient, request);\n    })();\n  }\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n\n\n  sendOperationRequest(operationArguments, operationSpec) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const endpoint = operationSpec.baseUrl || _this2._endpoint;\n\n      if (!endpoint) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n      } // Templatized URLs sometimes reference properties on the ServiceClient child class,\n      // so we have to pass `this` below in order to search these properties if they're\n      // not part of OperationArguments\n\n\n      const url = getRequestUrl(endpoint, operationSpec, operationArguments, _this2);\n      const request = createPipelineRequest({\n        url\n      });\n      request.method = operationSpec.httpMethod;\n      const operationInfo = getOperationRequestInfo(request);\n      operationInfo.operationSpec = operationSpec;\n      operationInfo.operationArguments = operationArguments;\n      const contentType = operationSpec.contentType || _this2._requestContentType;\n\n      if (contentType && operationSpec.requestBody) {\n        request.headers.set(\"Content-Type\", contentType);\n      }\n\n      const options = operationArguments.options;\n\n      if (options) {\n        const requestOptions = options.requestOptions;\n\n        if (requestOptions) {\n          if (requestOptions.timeout) {\n            request.timeout = requestOptions.timeout;\n          }\n\n          if (requestOptions.onUploadProgress) {\n            request.onUploadProgress = requestOptions.onUploadProgress;\n          }\n\n          if (requestOptions.onDownloadProgress) {\n            request.onDownloadProgress = requestOptions.onDownloadProgress;\n          }\n\n          if (requestOptions.shouldDeserialize !== undefined) {\n            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n          }\n\n          if (requestOptions.allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n          }\n        }\n\n        if (options.abortSignal) {\n          request.abortSignal = options.abortSignal;\n        }\n\n        if (options.tracingOptions) {\n          request.tracingOptions = options.tracingOptions;\n        }\n      }\n\n      if (_this2._allowInsecureConnection) {\n        request.allowInsecureConnection = true;\n      }\n\n      if (request.streamResponseStatusCodes === undefined) {\n        request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n      }\n\n      try {\n        const rawResponse = yield _this2.sendRequest(request);\n        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n\n        if (options === null || options === void 0 ? void 0 : options.onResponse) {\n          options.onResponse(rawResponse, flatResponse);\n        }\n\n        return flatResponse;\n      } catch (error) {\n        if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n          const rawResponse = error.response;\n          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n          error.details = flatResponse;\n\n          if (options === null || options === void 0 ? void 0 : options.onResponse) {\n            options.onResponse(rawResponse, flatResponse, error);\n          }\n        }\n\n        throw error;\n      }\n    })();\n  }\n\n}\n\nfunction createDefaultPipeline(options) {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions = options.credential && credentialScopes ? {\n    credentialScopes,\n    credential: options.credential\n  } : undefined;\n  return createClientPipeline(Object.assign(Object.assign({}, options), {\n    credentialOptions\n  }));\n}\n\nfunction getCredentialScopes(options) {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n  }\n\n  return undefined;\n}","map":{"version":3,"names":["createPipelineRequest","createClientPipeline","flattenResponse","getCachedDefaultHttpClient","getOperationRequestInfo","getRequestUrl","getStreamingResponseStatusCodes","logger","ServiceClient","constructor","options","_a","_b","_requestContentType","requestContentType","_endpoint","endpoint","baseUri","warning","_allowInsecureConnection","allowInsecureConnection","_httpClient","httpClient","pipeline","createDefaultPipeline","additionalPolicies","length","policy","position","afterPhase","undefined","addPolicy","sendRequest","request","sendOperationRequest","operationArguments","operationSpec","baseUrl","Error","url","method","httpMethod","operationInfo","contentType","requestBody","headers","set","requestOptions","timeout","onUploadProgress","onDownloadProgress","shouldDeserialize","abortSignal","tracingOptions","streamResponseStatusCodes","rawResponse","flatResponse","responses","status","onResponse","error","response","statusCode","details","credentialScopes","getCredentialScopes","credentialOptions","credential","Object","assign"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-client/dist-esm/src/serviceClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createPipelineRequest, } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\nimport { logger } from \"./log\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n    /**\n     * The ServiceClient constructor\n     * @param credential - The credentials used for authentication with the service.\n     * @param options - The service client options that govern the behavior of the client.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        this._requestContentType = options.requestContentType;\n        this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n        if (options.baseUri) {\n            logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n        }\n        this._allowInsecureConnection = options.allowInsecureConnection;\n        this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n        this.pipeline = options.pipeline || createDefaultPipeline(options);\n        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n            for (const { policy, position } of options.additionalPolicies) {\n                // Sign happens after Retry and is commonly needed to occur\n                // before policies that intercept post-retry.\n                const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n                this.pipeline.addPolicy(policy, {\n                    afterPhase,\n                });\n            }\n        }\n    }\n    /**\n     * Send the provided httpRequest.\n     */\n    async sendRequest(request) {\n        return this.pipeline.sendRequest(this._httpClient, request);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @typeParam T - The typed result of the request, based on the OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     */\n    async sendOperationRequest(operationArguments, operationSpec) {\n        const endpoint = operationSpec.baseUrl || this._endpoint;\n        if (!endpoint) {\n            throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n        }\n        // Templatized URLs sometimes reference properties on the ServiceClient child class,\n        // so we have to pass `this` below in order to search these properties if they're\n        // not part of OperationArguments\n        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n        const request = createPipelineRequest({\n            url,\n        });\n        request.method = operationSpec.httpMethod;\n        const operationInfo = getOperationRequestInfo(request);\n        operationInfo.operationSpec = operationSpec;\n        operationInfo.operationArguments = operationArguments;\n        const contentType = operationSpec.contentType || this._requestContentType;\n        if (contentType && operationSpec.requestBody) {\n            request.headers.set(\"Content-Type\", contentType);\n        }\n        const options = operationArguments.options;\n        if (options) {\n            const requestOptions = options.requestOptions;\n            if (requestOptions) {\n                if (requestOptions.timeout) {\n                    request.timeout = requestOptions.timeout;\n                }\n                if (requestOptions.onUploadProgress) {\n                    request.onUploadProgress = requestOptions.onUploadProgress;\n                }\n                if (requestOptions.onDownloadProgress) {\n                    request.onDownloadProgress = requestOptions.onDownloadProgress;\n                }\n                if (requestOptions.shouldDeserialize !== undefined) {\n                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n                }\n                if (requestOptions.allowInsecureConnection) {\n                    request.allowInsecureConnection = true;\n                }\n            }\n            if (options.abortSignal) {\n                request.abortSignal = options.abortSignal;\n            }\n            if (options.tracingOptions) {\n                request.tracingOptions = options.tracingOptions;\n            }\n        }\n        if (this._allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n        }\n        if (request.streamResponseStatusCodes === undefined) {\n            request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n        }\n        try {\n            const rawResponse = await this.sendRequest(request);\n            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n            if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                options.onResponse(rawResponse, flatResponse);\n            }\n            return flatResponse;\n        }\n        catch (error) {\n            if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n                const rawResponse = error.response;\n                const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n                error.details = flatResponse;\n                if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                    options.onResponse(rawResponse, flatResponse, error);\n                }\n            }\n            throw error;\n        }\n    }\n}\nfunction createDefaultPipeline(options) {\n    const credentialScopes = getCredentialScopes(options);\n    const credentialOptions = options.credential && credentialScopes\n        ? { credentialScopes, credential: options.credential }\n        : undefined;\n    return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));\n}\nfunction getCredentialScopes(options) {\n    if (options.credentialScopes) {\n        return options.credentialScopes;\n    }\n    if (options.endpoint) {\n        return `${options.endpoint}/.default`;\n    }\n    if (options.baseUri) {\n        return `${options.baseUri}/.default`;\n    }\n    if (options.credential && !options.credentialScopes) {\n        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n    }\n    return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}