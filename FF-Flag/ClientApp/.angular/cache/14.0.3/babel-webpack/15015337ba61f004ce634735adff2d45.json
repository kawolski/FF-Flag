{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\n/**\n * The sync token header, as described here:\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n * @internal\n */\n\nexport const SyncTokenHeaderName = \"sync-token\";\n/**\n * A policy factory for injecting sync tokens properly into outgoing requests.\n * @param syncTokens - the sync tokens store to be used across requests.\n * @internal\n */\n\nexport function syncTokenPolicy(syncTokens) {\n  return {\n    name: \"Sync Token Policy\",\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const syncTokenHeaderValue = syncTokens.getSyncTokenHeaderValue();\n\n        if (syncTokenHeaderValue) {\n          logger.info(\"[syncTokenPolicy] Setting headers with ${SyncTokenHeaderName} and ${syncTokenHeaderValue}\");\n          request.headers.set(SyncTokenHeaderName, syncTokenHeaderValue);\n        }\n\n        const response = yield next(request);\n        syncTokens.addSyncTokenFromHeaderValue(response.headers.get(SyncTokenHeaderName));\n        return response;\n      })();\n    }\n\n  };\n}\n/**\n * Sync token tracker (allows for real-time consistency, even in the face of\n * caching and load balancing within App Configuration).\n *\n * (protocol and format described here)\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n *\n * @internal\n */\n\nexport class SyncTokens {\n  constructor() {\n    this._currentSyncTokens = new Map();\n  }\n  /**\n   * Takes the value from the header named after the constant `SyncTokenHeaderName`\n   * and adds it to our list of accumulated sync tokens.\n   *\n   * If given an empty value (or undefined) it clears the current list of sync tokens.\n   * (indicates the service has properly absorbed values into the cluster).\n   *\n   * @param syncTokenHeaderValue - The full value of the sync token header.\n   */\n\n\n  addSyncTokenFromHeaderValue(syncTokenHeaderValue) {\n    if (syncTokenHeaderValue == null || syncTokenHeaderValue === \"\") {\n      // eventually everything gets synced up and we don't have to track\n      // these headers anymore\n      this._currentSyncTokens.clear();\n\n      return;\n    }\n\n    const newTokens = syncTokenHeaderValue.split(\",\").map(parseSyncToken);\n\n    for (const newToken of newTokens) {\n      const existingToken = this._currentSyncTokens.get(newToken.id);\n\n      if (!existingToken || existingToken.sequenceNumber < newToken.sequenceNumber) {\n        this._currentSyncTokens.set(newToken.id, newToken);\n\n        continue;\n      }\n    }\n  }\n  /**\n   * Gets a properly formatted SyncToken header value.\n   */\n\n\n  getSyncTokenHeaderValue() {\n    if (this._currentSyncTokens.size === 0) {\n      return undefined;\n    }\n\n    const syncTokenStrings = [];\n\n    for (const syncToken of this._currentSyncTokens.values()) {\n      // note that you don't include the 'sn' field here - that's only\n      // used for internal tracking of the 'version' for the token itself\n      syncTokenStrings.push(`${syncToken.id}=${syncToken.value}`);\n    }\n\n    return syncTokenStrings.join(\",\");\n  }\n\n} // An example sync token (from their documentation):\n//\n// jtqGc1I4=MDoyOA==;sn=28\n//\n// Which breaks down to:\n// id: jtqGc1I4\n// value: MDoyOA==\n// sequence number: 28\n\nconst syncTokenRegex = /^([^=]+)=([^;]+);sn=(\\d+)$/;\n/**\n * Parses a single sync token into it's constituent parts.\n *\n * @param syncToken - A single sync token.\n *\n * @internal\n */\n\nexport function parseSyncToken(syncToken) {\n  const matches = syncToken.match(syncTokenRegex);\n\n  if (matches == null) {\n    throw new Error(`Failed to parse sync token '${syncToken}' with regex ${syncTokenRegex.source}`);\n  }\n\n  const sequenceNumber = parseInt(matches[3], 10);\n\n  if (isNaN(sequenceNumber)) {\n    // this should be impossible since our regex restricts to just digits\n    // but there's nothing wrong with being thorough.\n    throw new Error(`${syncToken}: The sequence number value '${matches[3]}' wasn't a number`);\n  }\n\n  return {\n    id: matches[1],\n    value: matches[2],\n    sequenceNumber\n  };\n}","map":{"version":3,"names":["logger","SyncTokenHeaderName","syncTokenPolicy","syncTokens","name","sendRequest","request","next","syncTokenHeaderValue","getSyncTokenHeaderValue","info","headers","set","response","addSyncTokenFromHeaderValue","get","SyncTokens","constructor","_currentSyncTokens","Map","clear","newTokens","split","map","parseSyncToken","newToken","existingToken","id","sequenceNumber","size","undefined","syncTokenStrings","syncToken","values","push","value","join","syncTokenRegex","matches","match","Error","source","parseInt","isNaN"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/app-configuration/dist-esm/src/internal/synctokenpolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\n/**\n * The sync token header, as described here:\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n * @internal\n */\nexport const SyncTokenHeaderName = \"sync-token\";\n/**\n * A policy factory for injecting sync tokens properly into outgoing requests.\n * @param syncTokens - the sync tokens store to be used across requests.\n * @internal\n */\nexport function syncTokenPolicy(syncTokens) {\n    return {\n        name: \"Sync Token Policy\",\n        async sendRequest(request, next) {\n            const syncTokenHeaderValue = syncTokens.getSyncTokenHeaderValue();\n            if (syncTokenHeaderValue) {\n                logger.info(\"[syncTokenPolicy] Setting headers with ${SyncTokenHeaderName} and ${syncTokenHeaderValue}\");\n                request.headers.set(SyncTokenHeaderName, syncTokenHeaderValue);\n            }\n            const response = await next(request);\n            syncTokens.addSyncTokenFromHeaderValue(response.headers.get(SyncTokenHeaderName));\n            return response;\n        },\n    };\n}\n/**\n * Sync token tracker (allows for real-time consistency, even in the face of\n * caching and load balancing within App Configuration).\n *\n * (protocol and format described here)\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n *\n * @internal\n */\nexport class SyncTokens {\n    constructor() {\n        this._currentSyncTokens = new Map();\n    }\n    /**\n     * Takes the value from the header named after the constant `SyncTokenHeaderName`\n     * and adds it to our list of accumulated sync tokens.\n     *\n     * If given an empty value (or undefined) it clears the current list of sync tokens.\n     * (indicates the service has properly absorbed values into the cluster).\n     *\n     * @param syncTokenHeaderValue - The full value of the sync token header.\n     */\n    addSyncTokenFromHeaderValue(syncTokenHeaderValue) {\n        if (syncTokenHeaderValue == null || syncTokenHeaderValue === \"\") {\n            // eventually everything gets synced up and we don't have to track\n            // these headers anymore\n            this._currentSyncTokens.clear();\n            return;\n        }\n        const newTokens = syncTokenHeaderValue.split(\",\").map(parseSyncToken);\n        for (const newToken of newTokens) {\n            const existingToken = this._currentSyncTokens.get(newToken.id);\n            if (!existingToken || existingToken.sequenceNumber < newToken.sequenceNumber) {\n                this._currentSyncTokens.set(newToken.id, newToken);\n                continue;\n            }\n        }\n    }\n    /**\n     * Gets a properly formatted SyncToken header value.\n     */\n    getSyncTokenHeaderValue() {\n        if (this._currentSyncTokens.size === 0) {\n            return undefined;\n        }\n        const syncTokenStrings = [];\n        for (const syncToken of this._currentSyncTokens.values()) {\n            // note that you don't include the 'sn' field here - that's only\n            // used for internal tracking of the 'version' for the token itself\n            syncTokenStrings.push(`${syncToken.id}=${syncToken.value}`);\n        }\n        return syncTokenStrings.join(\",\");\n    }\n}\n// An example sync token (from their documentation):\n//\n// jtqGc1I4=MDoyOA==;sn=28\n//\n// Which breaks down to:\n// id: jtqGc1I4\n// value: MDoyOA==\n// sequence number: 28\nconst syncTokenRegex = /^([^=]+)=([^;]+);sn=(\\d+)$/;\n/**\n * Parses a single sync token into it's constituent parts.\n *\n * @param syncToken - A single sync token.\n *\n * @internal\n */\nexport function parseSyncToken(syncToken) {\n    const matches = syncToken.match(syncTokenRegex);\n    if (matches == null) {\n        throw new Error(`Failed to parse sync token '${syncToken}' with regex ${syncTokenRegex.source}`);\n    }\n    const sequenceNumber = parseInt(matches[3], 10);\n    if (isNaN(sequenceNumber)) {\n        // this should be impossible since our regex restricts to just digits\n        // but there's nothing wrong with being thorough.\n        throw new Error(`${syncToken}: The sequence number value '${matches[3]}' wasn't a number`);\n    }\n    return {\n        id: matches[1],\n        value: matches[2],\n        sequenceNumber,\n    };\n}\n"],"mappings":";AAAA;AACA;AACA,SAASA,MAAT,QAAuB,WAAvB;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,mBAAmB,GAAG,YAA5B;AACP;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,eAAT,CAAyBC,UAAzB,EAAqC;EACxC,OAAO;IACHC,IAAI,EAAE,mBADH;;IAEGC,WAAN,CAAkBC,OAAlB,EAA2BC,IAA3B,EAAiC;MAAA;QAC7B,MAAMC,oBAAoB,GAAGL,UAAU,CAACM,uBAAX,EAA7B;;QACA,IAAID,oBAAJ,EAA0B;UACtBR,MAAM,CAACU,IAAP,CAAY,2FAAZ;UACAJ,OAAO,CAACK,OAAR,CAAgBC,GAAhB,CAAoBX,mBAApB,EAAyCO,oBAAzC;QACH;;QACD,MAAMK,QAAQ,SAASN,IAAI,CAACD,OAAD,CAA3B;QACAH,UAAU,CAACW,2BAAX,CAAuCD,QAAQ,CAACF,OAAT,CAAiBI,GAAjB,CAAqBd,mBAArB,CAAvC;QACA,OAAOY,QAAP;MAR6B;IAShC;;EAXE,CAAP;AAaH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMG,UAAN,CAAiB;EACpBC,WAAW,GAAG;IACV,KAAKC,kBAAL,GAA0B,IAAIC,GAAJ,EAA1B;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIL,2BAA2B,CAACN,oBAAD,EAAuB;IAC9C,IAAIA,oBAAoB,IAAI,IAAxB,IAAgCA,oBAAoB,KAAK,EAA7D,EAAiE;MAC7D;MACA;MACA,KAAKU,kBAAL,CAAwBE,KAAxB;;MACA;IACH;;IACD,MAAMC,SAAS,GAAGb,oBAAoB,CAACc,KAArB,CAA2B,GAA3B,EAAgCC,GAAhC,CAAoCC,cAApC,CAAlB;;IACA,KAAK,MAAMC,QAAX,IAAuBJ,SAAvB,EAAkC;MAC9B,MAAMK,aAAa,GAAG,KAAKR,kBAAL,CAAwBH,GAAxB,CAA4BU,QAAQ,CAACE,EAArC,CAAtB;;MACA,IAAI,CAACD,aAAD,IAAkBA,aAAa,CAACE,cAAd,GAA+BH,QAAQ,CAACG,cAA9D,EAA8E;QAC1E,KAAKV,kBAAL,CAAwBN,GAAxB,CAA4Ba,QAAQ,CAACE,EAArC,EAAyCF,QAAzC;;QACA;MACH;IACJ;EACJ;EACD;AACJ;AACA;;;EACIhB,uBAAuB,GAAG;IACtB,IAAI,KAAKS,kBAAL,CAAwBW,IAAxB,KAAiC,CAArC,EAAwC;MACpC,OAAOC,SAAP;IACH;;IACD,MAAMC,gBAAgB,GAAG,EAAzB;;IACA,KAAK,MAAMC,SAAX,IAAwB,KAAKd,kBAAL,CAAwBe,MAAxB,EAAxB,EAA0D;MACtD;MACA;MACAF,gBAAgB,CAACG,IAAjB,CAAuB,GAAEF,SAAS,CAACL,EAAG,IAAGK,SAAS,CAACG,KAAM,EAAzD;IACH;;IACD,OAAOJ,gBAAgB,CAACK,IAAjB,CAAsB,GAAtB,CAAP;EACH;;AA3CmB,C,CA6CxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,cAAc,GAAG,4BAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASb,cAAT,CAAwBQ,SAAxB,EAAmC;EACtC,MAAMM,OAAO,GAAGN,SAAS,CAACO,KAAV,CAAgBF,cAAhB,CAAhB;;EACA,IAAIC,OAAO,IAAI,IAAf,EAAqB;IACjB,MAAM,IAAIE,KAAJ,CAAW,+BAA8BR,SAAU,gBAAeK,cAAc,CAACI,MAAO,EAAxF,CAAN;EACH;;EACD,MAAMb,cAAc,GAAGc,QAAQ,CAACJ,OAAO,CAAC,CAAD,CAAR,EAAa,EAAb,CAA/B;;EACA,IAAIK,KAAK,CAACf,cAAD,CAAT,EAA2B;IACvB;IACA;IACA,MAAM,IAAIY,KAAJ,CAAW,GAAER,SAAU,gCAA+BM,OAAO,CAAC,CAAD,CAAI,mBAAjE,CAAN;EACH;;EACD,OAAO;IACHX,EAAE,EAAEW,OAAO,CAAC,CAAD,CADR;IAEHH,KAAK,EAAEG,OAAO,CAAC,CAAD,CAFX;IAGHV;EAHG,CAAP;AAKH"},"metadata":{},"sourceType":"module"}