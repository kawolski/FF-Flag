{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\n\nexport function getPagedAsyncIterator(pagedResult) {\n  var _a;\n\n  const iter = getItemAsyncIterator(pagedResult);\n  return {\n    next() {\n      return iter.next();\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : settings => {\n      const {\n        continuationToken,\n        maxPageSize\n      } = settings !== null && settings !== void 0 ? settings : {};\n      return getPageAsyncIterator(pagedResult, {\n        pageLink: continuationToken,\n        maxPageSize\n      });\n    }\n  };\n}\n\nfunction getItemAsyncIterator(pagedResult) {\n  return __asyncGenerator(this, arguments, function* getItemAsyncIterator_1() {\n    var e_1, _a, e_2, _b;\n\n    const pages = getPageAsyncIterator(pagedResult);\n    const firstVal = yield __await(pages.next()); // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n\n    if (!Array.isArray(firstVal.value)) {\n      // can extract elements from this page\n      const {\n        toElements\n      } = pagedResult;\n\n      if (toElements) {\n        yield __await(yield* __asyncDelegator(__asyncValues(toElements(firstVal.value))));\n\n        try {\n          for (var pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = yield __await(pages_1.next()), !pages_1_1.done;) {\n            const page = pages_1_1.value;\n            yield __await(yield* __asyncDelegator(__asyncValues(toElements(page))));\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield __await(_a.call(pages_1));\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } else {\n        yield yield __await(firstVal.value); // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n\n        yield __await(yield* __asyncDelegator(__asyncValues(pages)));\n      }\n    } else {\n      yield __await(yield* __asyncDelegator(__asyncValues(firstVal.value)));\n\n      try {\n        for (var pages_2 = __asyncValues(pages), pages_2_1; pages_2_1 = yield __await(pages_2.next()), !pages_2_1.done;) {\n          const page = pages_2_1.value; // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n          // it must be the case that `TPage = TElement[]`\n\n          yield __await(yield* __asyncDelegator(__asyncValues(page)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (pages_2_1 && !pages_2_1.done && (_b = pages_2.return)) yield __await(_b.call(pages_2));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  });\n}\n\nfunction getPageAsyncIterator(pagedResult, options = {}) {\n  return __asyncGenerator(this, arguments, function* getPageAsyncIterator_1() {\n    const {\n      pageLink,\n      maxPageSize\n    } = options;\n    let response = yield __await(pagedResult.getPage(pageLink !== null && pageLink !== void 0 ? pageLink : pagedResult.firstPageLink, maxPageSize));\n\n    if (!response) {\n      return yield __await(void 0);\n    }\n\n    yield yield __await(response.page);\n\n    while (response.nextPageLink) {\n      response = yield __await(pagedResult.getPage(response.nextPageLink, maxPageSize));\n\n      if (!response) {\n        return yield __await(void 0);\n      }\n\n      yield yield __await(response.page);\n    }\n  });\n}","map":{"version":3,"names":["__asyncDelegator","__asyncGenerator","__asyncValues","__await","getPagedAsyncIterator","pagedResult","_a","iter","getItemAsyncIterator","next","Symbol","asyncIterator","byPage","settings","continuationToken","maxPageSize","getPageAsyncIterator","pageLink","arguments","getItemAsyncIterator_1","e_1","e_2","_b","pages","firstVal","Array","isArray","value","toElements","pages_1","pages_1_1","done","page","e_1_1","error","return","call","pages_2","pages_2_1","e_2_1","options","getPageAsyncIterator_1","response","getPage","firstPageLink","nextPageLink"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-paging/dist-esm/src/getPagedAsyncIterator.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\n/**\n * returns an async iterator that iterates over results. It also has a `byPage`\n * method that returns pages of items at once.\n *\n * @param pagedResult - an object that specifies how to get pages.\n * @returns a paged async iterator that iterates over results.\n */\nexport function getPagedAsyncIterator(pagedResult) {\n    var _a;\n    const iter = getItemAsyncIterator(pagedResult);\n    return {\n        next() {\n            return iter.next();\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n        byPage: (_a = pagedResult === null || pagedResult === void 0 ? void 0 : pagedResult.byPage) !== null && _a !== void 0 ? _a : ((settings) => {\n            const { continuationToken, maxPageSize } = settings !== null && settings !== void 0 ? settings : {};\n            return getPageAsyncIterator(pagedResult, {\n                pageLink: continuationToken,\n                maxPageSize,\n            });\n        }),\n    };\n}\nfunction getItemAsyncIterator(pagedResult) {\n    return __asyncGenerator(this, arguments, function* getItemAsyncIterator_1() {\n        var e_1, _a, e_2, _b;\n        const pages = getPageAsyncIterator(pagedResult);\n        const firstVal = yield __await(pages.next());\n        // if the result does not have an array shape, i.e. TPage = TElement, then we return it as is\n        if (!Array.isArray(firstVal.value)) {\n            // can extract elements from this page\n            const { toElements } = pagedResult;\n            if (toElements) {\n                yield __await(yield* __asyncDelegator(__asyncValues(toElements(firstVal.value))));\n                try {\n                    for (var pages_1 = __asyncValues(pages), pages_1_1; pages_1_1 = yield __await(pages_1.next()), !pages_1_1.done;) {\n                        const page = pages_1_1.value;\n                        yield __await(yield* __asyncDelegator(__asyncValues(toElements(page))));\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (pages_1_1 && !pages_1_1.done && (_a = pages_1.return)) yield __await(_a.call(pages_1));\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n            else {\n                yield yield __await(firstVal.value);\n                // `pages` is of type `AsyncIterableIterator<TPage>` but TPage = TElement in this case\n                yield __await(yield* __asyncDelegator(__asyncValues(pages)));\n            }\n        }\n        else {\n            yield __await(yield* __asyncDelegator(__asyncValues(firstVal.value)));\n            try {\n                for (var pages_2 = __asyncValues(pages), pages_2_1; pages_2_1 = yield __await(pages_2.next()), !pages_2_1.done;) {\n                    const page = pages_2_1.value;\n                    // pages is of type `AsyncIterableIterator<TPage>` so `page` is of type `TPage`. In this branch,\n                    // it must be the case that `TPage = TElement[]`\n                    yield __await(yield* __asyncDelegator(__asyncValues(page)));\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (pages_2_1 && !pages_2_1.done && (_b = pages_2.return)) yield __await(_b.call(pages_2));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    });\n}\nfunction getPageAsyncIterator(pagedResult, options = {}) {\n    return __asyncGenerator(this, arguments, function* getPageAsyncIterator_1() {\n        const { pageLink, maxPageSize } = options;\n        let response = yield __await(pagedResult.getPage(pageLink !== null && pageLink !== void 0 ? pageLink : pagedResult.firstPageLink, maxPageSize));\n        if (!response) {\n            return yield __await(void 0);\n        }\n        yield yield __await(response.page);\n        while (response.nextPageLink) {\n            response = yield __await(pagedResult.getPage(response.nextPageLink, maxPageSize));\n            if (!response) {\n                return yield __await(void 0);\n            }\n            yield yield __await(response.page);\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}