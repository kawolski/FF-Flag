{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\n\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\n\nfunction sendAuthorizeRequest(_x) {\n  return _sendAuthorizeRequest.apply(this, arguments);\n}\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\n\n\nfunction _sendAuthorizeRequest() {\n  _sendAuthorizeRequest = _asyncToGenerator(function* (options) {\n    var _a, _b;\n\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions\n    };\n    return (_b = (_a = yield getAccessToken(scopes, getTokenOptions)) === null || _a === void 0 ? void 0 : _a.token) !== null && _b !== void 0 ? _b : \"\";\n  });\n  return _sendAuthorizeRequest.apply(this, arguments);\n}\n\nexport function auxiliaryAuthenticationHeaderPolicy(options) {\n  const {\n    credentials,\n    scopes\n  } = options;\n  const logger = options.logger || coreLogger;\n  const tokenCyclerMap = new WeakMap();\n  return {\n    name: auxiliaryAuthenticationHeaderPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n\n        if (!credentials || credentials.length === 0) {\n          logger.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);\n          return next(request);\n        }\n\n        const tokenPromises = [];\n\n        for (const credential of credentials) {\n          let getAccessToken = tokenCyclerMap.get(credential);\n\n          if (!getAccessToken) {\n            getAccessToken = createTokenCycler(credential);\n            tokenCyclerMap.set(credential, getAccessToken);\n          }\n\n          tokenPromises.push(sendAuthorizeRequest({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            getAccessToken,\n            logger\n          }));\n        }\n\n        const auxiliaryTokens = (yield Promise.all(tokenPromises)).filter(token => Boolean(token));\n\n        if (auxiliaryTokens.length === 0) {\n          logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);\n          return next(request);\n        }\n\n        request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map(token => `Bearer ${token}`).join(\", \"));\n        return next(request);\n      })();\n    }\n\n  };\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","auxiliaryAuthenticationHeaderPolicyName","AUTHORIZATION_AUXILIARY_HEADER","sendAuthorizeRequest","options","_a","_b","scopes","getAccessToken","request","getTokenOptions","abortSignal","tracingOptions","token","auxiliaryAuthenticationHeaderPolicy","credentials","tokenCyclerMap","WeakMap","name","sendRequest","next","url","toLowerCase","startsWith","Error","length","info","tokenPromises","credential","get","set","push","Array","isArray","auxiliaryTokens","Promise","all","filter","Boolean","warning","headers","map","join"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/auxiliaryAuthenticationHeaderPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\nasync function sendAuthorizeRequest(options) {\n    var _a, _b;\n    const { scopes, getAccessToken, request } = options;\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n    };\n    return (_b = (_a = (await getAccessToken(scopes, getTokenOptions))) === null || _a === void 0 ? void 0 : _a.token) !== null && _b !== void 0 ? _b : \"\";\n}\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(options) {\n    const { credentials, scopes } = options;\n    const logger = options.logger || coreLogger;\n    const tokenCyclerMap = new WeakMap();\n    return {\n        name: auxiliaryAuthenticationHeaderPolicyName,\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            if (!credentials || credentials.length === 0) {\n                logger.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);\n                return next(request);\n            }\n            const tokenPromises = [];\n            for (const credential of credentials) {\n                let getAccessToken = tokenCyclerMap.get(credential);\n                if (!getAccessToken) {\n                    getAccessToken = createTokenCycler(credential);\n                    tokenCyclerMap.set(credential, getAccessToken);\n                }\n                tokenPromises.push(sendAuthorizeRequest({\n                    scopes: Array.isArray(scopes) ? scopes : [scopes],\n                    request,\n                    getAccessToken,\n                    logger,\n                }));\n            }\n            const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));\n            if (auxiliaryTokens.length === 0) {\n                logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);\n                return next(request);\n            }\n            request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(\", \"));\n            return next(request);\n        },\n    };\n}\n"],"mappings":";AAAA;AACA;AACA,SAASA,iBAAT,QAAkC,qBAAlC;AACA,SAASC,MAAM,IAAIC,UAAnB,QAAqC,QAArC;AACA;AACA;AACA;;AACA,OAAO,MAAMC,uCAAuC,GAAG,qCAAhD;AACP,MAAMC,8BAA8B,GAAG,8BAAvC;;SACeC,oB;;;AASf;AACA;AACA;AACA;AACA;AACA;;;;4CAdA,WAAoCC,OAApC,EAA6C;IACzC,IAAIC,EAAJ,EAAQC,EAAR;;IACA,MAAM;MAAEC,MAAF;MAAUC,cAAV;MAA0BC;IAA1B,IAAsCL,OAA5C;IACA,MAAMM,eAAe,GAAG;MACpBC,WAAW,EAAEF,OAAO,CAACE,WADD;MAEpBC,cAAc,EAAEH,OAAO,CAACG;IAFJ,CAAxB;IAIA,OAAO,CAACN,EAAE,GAAG,CAACD,EAAE,SAAUG,cAAc,CAACD,MAAD,EAASG,eAAT,CAA3B,MAA2D,IAA3D,IAAmEL,EAAE,KAAK,KAAK,CAA/E,GAAmF,KAAK,CAAxF,GAA4FA,EAAE,CAACQ,KAArG,MAAgH,IAAhH,IAAwHP,EAAE,KAAK,KAAK,CAApI,GAAwIA,EAAxI,GAA6I,EAApJ;EACH,C;;;;AAOD,OAAO,SAASQ,mCAAT,CAA6CV,OAA7C,EAAsD;EACzD,MAAM;IAAEW,WAAF;IAAeR;EAAf,IAA0BH,OAAhC;EACA,MAAML,MAAM,GAAGK,OAAO,CAACL,MAAR,IAAkBC,UAAjC;EACA,MAAMgB,cAAc,GAAG,IAAIC,OAAJ,EAAvB;EACA,OAAO;IACHC,IAAI,EAAEjB,uCADH;;IAEGkB,WAAN,CAAkBV,OAAlB,EAA2BW,IAA3B,EAAiC;MAAA;QAC7B,IAAI,CAACX,OAAO,CAACY,GAAR,CAAYC,WAAZ,GAA0BC,UAA1B,CAAqC,UAArC,CAAL,EAAuD;UACnD,MAAM,IAAIC,KAAJ,CAAU,2GAAV,CAAN;QACH;;QACD,IAAI,CAACT,WAAD,IAAgBA,WAAW,CAACU,MAAZ,KAAuB,CAA3C,EAA8C;UAC1C1B,MAAM,CAAC2B,IAAP,CAAa,GAAEzB,uCAAwC,mDAAvD;UACA,OAAOmB,IAAI,CAACX,OAAD,CAAX;QACH;;QACD,MAAMkB,aAAa,GAAG,EAAtB;;QACA,KAAK,MAAMC,UAAX,IAAyBb,WAAzB,EAAsC;UAClC,IAAIP,cAAc,GAAGQ,cAAc,CAACa,GAAf,CAAmBD,UAAnB,CAArB;;UACA,IAAI,CAACpB,cAAL,EAAqB;YACjBA,cAAc,GAAGV,iBAAiB,CAAC8B,UAAD,CAAlC;YACAZ,cAAc,CAACc,GAAf,CAAmBF,UAAnB,EAA+BpB,cAA/B;UACH;;UACDmB,aAAa,CAACI,IAAd,CAAmB5B,oBAAoB,CAAC;YACpCI,MAAM,EAAEyB,KAAK,CAACC,OAAN,CAAc1B,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CADL;YAEpCE,OAFoC;YAGpCD,cAHoC;YAIpCT;UAJoC,CAAD,CAAvC;QAMH;;QACD,MAAMmC,eAAe,GAAG,OAAOC,OAAO,CAACC,GAAR,CAAYT,aAAZ,CAAP,EAAmCU,MAAnC,CAA2CxB,KAAD,IAAWyB,OAAO,CAACzB,KAAD,CAA5D,CAAxB;;QACA,IAAIqB,eAAe,CAACT,MAAhB,KAA2B,CAA/B,EAAkC;UAC9B1B,MAAM,CAACwC,OAAP,CAAgB,2CAA0CrC,8BAA+B,0BAAzF;UACA,OAAOkB,IAAI,CAACX,OAAD,CAAX;QACH;;QACDA,OAAO,CAAC+B,OAAR,CAAgBV,GAAhB,CAAoB5B,8BAApB,EAAoDgC,eAAe,CAACO,GAAhB,CAAqB5B,KAAD,IAAY,UAASA,KAAM,EAA/C,EAAkD6B,IAAlD,CAAuD,IAAvD,CAApD;QACA,OAAOtB,IAAI,CAACX,OAAD,CAAX;MA5B6B;IA6BhC;;EA/BE,CAAP;AAiCH"},"metadata":{},"sourceType":"module"}