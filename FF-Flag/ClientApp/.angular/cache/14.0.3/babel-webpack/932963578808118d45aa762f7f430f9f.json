{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\nconst CollectionFormatToDelimiterMap = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\"\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n  let isAbsolutePath = false;\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n\n  if (operationSpec.path) {\n    let path = replaceAll(operationSpec.path, urlReplacements); // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    } // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n\n\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n\n  const {\n    queryParams,\n    sequenceParams\n  } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n  return requestUrl;\n}\n\nfunction replaceAll(input, replacements) {\n  let result = input;\n\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n\n  return result;\n}\n\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n\n  const result = new Map();\n\n  if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n\n      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n    }\n  }\n\n  return result;\n}\n\nfunction isAbsoluteUrl(url) {\n  return url.includes(\"://\");\n}\n\nfunction appendPath(url, pathToAppend) {\n  if (!pathToAppend) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n\n  const searchStart = pathToAppend.indexOf(\"?\");\n\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n\n  parsedUrl.pathname = newPath;\n  return parsedUrl.toString();\n}\n\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n\n  const result = new Map();\n  const sequenceParams = new Set();\n\n  if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n        sequenceParams.add(queryParameter.mapper.serializedName);\n      }\n\n      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n\n      if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {\n        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : \"\";\n\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map(item => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n\n            return item;\n          });\n        }\n\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map(item => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        } // Join pipes and CSV *after* encoding, or the server will be upset.\n\n\n        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n\n        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n      }\n    }\n  }\n\n  return {\n    queryParams: result,\n    sequenceParams\n  };\n}\n\nfunction simpleParseQueryParams(queryString) {\n  const result = new Map();\n\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  } // remove the leading ?\n\n\n  queryString = queryString.slice(1);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const [name, value] = pair.split(\"=\", 2);\n    const existingValue = result.get(name);\n\n    if (existingValue) {\n      if (Array.isArray(existingValue)) {\n        existingValue.push(value);\n      } else {\n        result.set(name, [existingValue, value]);\n      }\n    } else {\n      result.set(name, value);\n    }\n  }\n\n  return result;\n}\n/** @internal */\n\n\nexport function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {\n  if (queryParams.size === 0) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url); // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n\n  const combinedParams = simpleParseQueryParams(parsedUrl.search);\n\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n\n    if (Array.isArray(existingValue)) {\n      if (Array.isArray(value)) {\n        existingValue.push(...value);\n        const valueSet = new Set(existingValue);\n        combinedParams.set(name, Array.from(valueSet));\n      } else {\n        existingValue.push(value);\n      }\n    } else if (existingValue) {\n      if (Array.isArray(value)) {\n        value.unshift(existingValue);\n      } else if (sequenceParams.has(name)) {\n        combinedParams.set(name, [existingValue, value]);\n      }\n\n      if (!noOverwrite) {\n        combinedParams.set(name, value);\n      }\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n\n  const searchPieces = [];\n\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else if (Array.isArray(value)) {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    } else {\n      searchPieces.push(`${name}=${value}`);\n    }\n  } // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n\n\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}","map":{"version":3,"names":["getOperationArgumentValueFromParameter","getPathStringFromParameter","CollectionFormatToDelimiterMap","CSV","SSV","Multi","TSV","Pipes","getRequestUrl","baseUri","operationSpec","operationArguments","fallbackObject","urlReplacements","calculateUrlReplacements","isAbsolutePath","requestUrl","replaceAll","path","startsWith","substring","isAbsoluteUrl","appendPath","queryParams","sequenceParams","calculateQueryParameters","appendQueryParams","input","replacements","result","searchValue","replaceValue","split","join","_a","Map","urlParameters","length","urlParameter","urlParameterValue","parameterPathString","serializer","serialize","mapper","skipEncoding","encodeURIComponent","set","serializedName","url","includes","pathToAppend","parsedUrl","URL","newPath","pathname","endsWith","searchStart","indexOf","search","toString","Set","queryParameters","queryParameter","type","name","add","queryParameterValue","undefined","required","delimiter","collectionFormat","Array","isArray","map","item","simpleParseQueryParams","queryString","slice","pairs","pair","value","existingValue","get","push","noOverwrite","size","combinedParams","valueSet","from","unshift","has","searchPieces","subValue"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-client/dist-esm/src/urlHelpers.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\nconst CollectionFormatToDelimiterMap = {\n    CSV: \",\",\n    SSV: \" \",\n    Multi: \"Multi\",\n    TSV: \"\\t\",\n    Pipes: \"|\",\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n    let isAbsolutePath = false;\n    let requestUrl = replaceAll(baseUri, urlReplacements);\n    if (operationSpec.path) {\n        let path = replaceAll(operationSpec.path, urlReplacements);\n        // QUIRK: sometimes we get a path component like /{nextLink}\n        // which may be a fully formed URL with a leading /. In that case, we should\n        // remove the leading /\n        if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        // QUIRK: sometimes we get a path component like {nextLink}\n        // which may be a fully formed URL. In that case, we should\n        // ignore the baseUri.\n        if (isAbsoluteUrl(path)) {\n            requestUrl = path;\n            isAbsolutePath = true;\n        }\n        else {\n            requestUrl = appendPath(requestUrl, path);\n        }\n    }\n    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n    /**\n     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n     * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n     * is still being built so there is nothing to overwrite.\n     */\n    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n    return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n    let result = input;\n    for (const [searchValue, replaceValue] of replacements) {\n        result = result.split(searchValue).join(replaceValue);\n    }\n    return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const urlParameter of operationSpec.urlParameters) {\n            let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n            const parameterPathString = getPathStringFromParameter(urlParameter);\n            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n            if (!urlParameter.skipEncoding) {\n                urlParameterValue = encodeURIComponent(urlParameterValue);\n            }\n            result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n        }\n    }\n    return result;\n}\nfunction isAbsoluteUrl(url) {\n    return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n    if (!pathToAppend) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    let newPath = parsedUrl.pathname;\n    if (!newPath.endsWith(\"/\")) {\n        newPath = `${newPath}/`;\n    }\n    if (pathToAppend.startsWith(\"/\")) {\n        pathToAppend = pathToAppend.substring(1);\n    }\n    const searchStart = pathToAppend.indexOf(\"?\");\n    if (searchStart !== -1) {\n        const path = pathToAppend.substring(0, searchStart);\n        const search = pathToAppend.substring(searchStart + 1);\n        newPath = newPath + path;\n        if (search) {\n            parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n        }\n    }\n    else {\n        newPath = newPath + pathToAppend;\n    }\n    parsedUrl.pathname = newPath;\n    return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    const sequenceParams = new Set();\n    if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const queryParameter of operationSpec.queryParameters) {\n            if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n                sequenceParams.add(queryParameter.mapper.serializedName);\n            }\n            let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n            if ((queryParameterValue !== undefined && queryParameterValue !== null) ||\n                queryParameter.mapper.required) {\n                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n                const delimiter = queryParameter.collectionFormat\n                    ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n                    : \"\";\n                if (Array.isArray(queryParameterValue)) {\n                    // replace null and undefined\n                    queryParameterValue = queryParameterValue.map((item) => {\n                        if (item === null || item === undefined) {\n                            return \"\";\n                        }\n                        return item;\n                    });\n                }\n                if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n                    continue;\n                }\n                else if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                if (!queryParameter.skipEncoding) {\n                    if (Array.isArray(queryParameterValue)) {\n                        queryParameterValue = queryParameterValue.map((item) => {\n                            return encodeURIComponent(item);\n                        });\n                    }\n                    else {\n                        queryParameterValue = encodeURIComponent(queryParameterValue);\n                    }\n                }\n                // Join pipes and CSV *after* encoding, or the server will be upset.\n                if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n            }\n        }\n    }\n    return {\n        queryParams: result,\n        sequenceParams,\n    };\n}\nfunction simpleParseQueryParams(queryString) {\n    const result = new Map();\n    if (!queryString || queryString[0] !== \"?\") {\n        return result;\n    }\n    // remove the leading ?\n    queryString = queryString.slice(1);\n    const pairs = queryString.split(\"&\");\n    for (const pair of pairs) {\n        const [name, value] = pair.split(\"=\", 2);\n        const existingValue = result.get(name);\n        if (existingValue) {\n            if (Array.isArray(existingValue)) {\n                existingValue.push(value);\n            }\n            else {\n                result.set(name, [existingValue, value]);\n            }\n        }\n        else {\n            result.set(name, value);\n        }\n    }\n    return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {\n    if (queryParams.size === 0) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n    // can change their meaning to the server, such as in the case of a SAS signature.\n    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n    const combinedParams = simpleParseQueryParams(parsedUrl.search);\n    for (const [name, value] of queryParams) {\n        const existingValue = combinedParams.get(name);\n        if (Array.isArray(existingValue)) {\n            if (Array.isArray(value)) {\n                existingValue.push(...value);\n                const valueSet = new Set(existingValue);\n                combinedParams.set(name, Array.from(valueSet));\n            }\n            else {\n                existingValue.push(value);\n            }\n        }\n        else if (existingValue) {\n            if (Array.isArray(value)) {\n                value.unshift(existingValue);\n            }\n            else if (sequenceParams.has(name)) {\n                combinedParams.set(name, [existingValue, value]);\n            }\n            if (!noOverwrite) {\n                combinedParams.set(name, value);\n            }\n        }\n        else {\n            combinedParams.set(name, value);\n        }\n    }\n    const searchPieces = [];\n    for (const [name, value] of combinedParams) {\n        if (typeof value === \"string\") {\n            searchPieces.push(`${name}=${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // QUIRK: If we get an array of values, include multiple key/value pairs\n            for (const subValue of value) {\n                searchPieces.push(`${name}=${subValue}`);\n            }\n        }\n        else {\n            searchPieces.push(`${name}=${value}`);\n        }\n    }\n    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n    parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n    return parsedUrl.toString();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}