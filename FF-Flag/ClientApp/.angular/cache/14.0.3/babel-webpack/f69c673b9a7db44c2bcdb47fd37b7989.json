{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n  return mapperTypeName !== \"Composite\" && mapperTypeName !== \"Dictionary\" && (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\n\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\n\nexport function isValidUuid(uuid) {\n  return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\n\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n\n  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n    return responseObject.shouldWrapBody ? {\n      body: null\n    } : null;\n  } else {\n    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), {\n      body: responseObject.body\n    }) : combinedHeadersAndBody;\n  }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\n\n\nexport function flattenResponse(fullResponse, responseSpec) {\n  var _a, _b;\n\n  const parsedHeaders = fullResponse.parsedHeaders; // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n\n  if (fullResponse.request.method === \"HEAD\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      body: fullResponse.parsedBody\n    });\n  }\n\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n  /** If the body is asked for, we look at the expected body type to handle it */\n\n  if (expectedBodyTypeName === \"Stream\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody\n    });\n  }\n\n  const modelProperties = expectedBodyTypeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n  const isPageableResponse = Object.keys(modelProperties).some(k => modelProperties[k].serializedName === \"\");\n\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n\n    for (const key of Object.keys(modelProperties)) {\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n      }\n    }\n\n    if (parsedHeaders) {\n      for (const key of Object.keys(parsedHeaders)) {\n        arrayResponse[key] = parsedHeaders[key];\n      }\n    }\n\n    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;\n  }\n\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)\n  });\n}","map":{"version":3,"names":["isPrimitiveBody","value","mapperTypeName","match","undefined","validateISODuration","isDuration","test","validUuidRegex","isValidUuid","uuid","handleNullableResponseAndWrappableBody","responseObject","combinedHeadersAndBody","Object","assign","headers","body","hasNullableType","getOwnPropertyNames","length","shouldWrapBody","flattenResponse","fullResponse","responseSpec","_a","_b","parsedHeaders","request","method","parsedBody","bodyMapper","isNullable","Boolean","nullable","expectedBodyTypeName","type","name","blobBody","readableStreamBody","modelProperties","isPageableResponse","keys","some","k","serializedName","arrayResponse","key"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-client/dist-esm/src/utils.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n    return (mapperTypeName !== \"Composite\" &&\n        mapperTypeName !== \"Dictionary\" &&\n        (typeof value === \"string\" ||\n            typeof value === \"number\" ||\n            typeof value === \"boolean\" ||\n            (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !==\n                null ||\n            value === undefined ||\n            value === null));\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n    return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n    return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n    if (responseObject.hasNullableType &&\n        Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n        return responseObject.shouldWrapBody ? { body: null } : null;\n    }\n    else {\n        return responseObject.shouldWrapBody\n            ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;\n    }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n    var _a, _b;\n    const parsedHeaders = fullResponse.parsedHeaders;\n    // head methods never have a body, but we return a boolean set to body property\n    // to indicate presence/absence of the resource\n    if (fullResponse.request.method === \"HEAD\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });\n    }\n    const bodyMapper = responseSpec && responseSpec.bodyMapper;\n    const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n    const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n    /** If the body is asked for, we look at the expected body type to handle it */\n    if (expectedBodyTypeName === \"Stream\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });\n    }\n    const modelProperties = (expectedBodyTypeName === \"Composite\" &&\n        bodyMapper.type.modelProperties) ||\n        {};\n    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === \"\");\n    if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n        const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n        for (const key of Object.keys(modelProperties)) {\n            if (modelProperties[key].serializedName) {\n                arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n            }\n        }\n        if (parsedHeaders) {\n            for (const key of Object.keys(parsedHeaders)) {\n                arrayResponse[key] = parsedHeaders[key];\n            }\n        }\n        return isNullable &&\n            !fullResponse.parsedBody &&\n            !parsedHeaders &&\n            Object.getOwnPropertyNames(modelProperties).length === 0\n            ? null\n            : arrayResponse;\n    }\n    return handleNullableResponseAndWrappableBody({\n        body: fullResponse.parsedBody,\n        headers: parsedHeaders,\n        hasNullableType: isNullable,\n        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),\n    });\n}\n"],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,eAAT,CAAyBC,KAAzB,EAAgCC,cAAhC,EAAgD;EACnD,OAAQA,cAAc,KAAK,WAAnB,IACJA,cAAc,KAAK,YADf,KAEH,OAAOD,KAAP,KAAiB,QAAjB,IACG,OAAOA,KAAP,KAAiB,QADpB,IAEG,OAAOA,KAAP,KAAiB,SAFpB,IAGG,CAACC,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACC,KAAf,CAAqB,iEAArB,CAAjE,MACI,IAJP,IAKGF,KAAK,KAAKG,SALb,IAMGH,KAAK,KAAK,IARV,CAAR;AASH;AACD,MAAMI,mBAAmB,GAAG,qKAA5B;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBL,KAApB,EAA2B;EAC9B,OAAOI,mBAAmB,CAACE,IAApB,CAAyBN,KAAzB,CAAP;AACH;AACD,MAAMO,cAAc,GAAG,gFAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2B;EAC9B,OAAOF,cAAc,CAACD,IAAf,CAAoBG,IAApB,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,sCAAT,CAAgDC,cAAhD,EAAgE;EAC5D,MAAMC,sBAAsB,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,cAAc,CAACI,OAAjC,CAAd,EAAyDJ,cAAc,CAACK,IAAxE,CAA/B;;EACA,IAAIL,cAAc,CAACM,eAAf,IACAJ,MAAM,CAACK,mBAAP,CAA2BN,sBAA3B,EAAmDO,MAAnD,KAA8D,CADlE,EACqE;IACjE,OAAOR,cAAc,CAACS,cAAf,GAAgC;MAAEJ,IAAI,EAAE;IAAR,CAAhC,GAAiD,IAAxD;EACH,CAHD,MAIK;IACD,OAAOL,cAAc,CAACS,cAAf,GACDP,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,cAAc,CAACI,OAAjC,CAAd,EAAyD;MAAEC,IAAI,EAAEL,cAAc,CAACK;IAAvB,CAAzD,CADC,GACyFJ,sBADhG;EAEH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASS,eAAT,CAAyBC,YAAzB,EAAuCC,YAAvC,EAAqD;EACxD,IAAIC,EAAJ,EAAQC,EAAR;;EACA,MAAMC,aAAa,GAAGJ,YAAY,CAACI,aAAnC,CAFwD,CAGxD;EACA;;EACA,IAAIJ,YAAY,CAACK,OAAb,CAAqBC,MAArB,KAAgC,MAApC,EAA4C;IACxC,OAAOf,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBY,aAAlB,CAAd,EAAgD;MAAEV,IAAI,EAAEM,YAAY,CAACO;IAArB,CAAhD,CAAP;EACH;;EACD,MAAMC,UAAU,GAAGP,YAAY,IAAIA,YAAY,CAACO,UAAhD;EACA,MAAMC,UAAU,GAAGC,OAAO,CAACF,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACG,QAApE,CAA1B;EACA,MAAMC,oBAAoB,GAAGJ,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACK,IAAX,CAAgBC,IAArG;EACA;;EACA,IAAIF,oBAAoB,KAAK,QAA7B,EAAuC;IACnC,OAAOrB,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBY,aAAlB,CAAd,EAAgD;MAAEW,QAAQ,EAAEf,YAAY,CAACe,QAAzB;MAAmCC,kBAAkB,EAAEhB,YAAY,CAACgB;IAApE,CAAhD,CAAP;EACH;;EACD,MAAMC,eAAe,GAAIL,oBAAoB,KAAK,WAAzB,IACrBJ,UAAU,CAACK,IAAX,CAAgBI,eADI,IAEpB,EAFJ;EAGA,MAAMC,kBAAkB,GAAG3B,MAAM,CAAC4B,IAAP,CAAYF,eAAZ,EAA6BG,IAA7B,CAAmCC,CAAD,IAAOJ,eAAe,CAACI,CAAD,CAAf,CAAmBC,cAAnB,KAAsC,EAA/E,CAA3B;;EACA,IAAIV,oBAAoB,KAAK,UAAzB,IAAuCM,kBAA3C,EAA+D;IAC3D,MAAMK,aAAa,GAAG,CAACrB,EAAE,GAAGF,YAAY,CAACO,UAAnB,MAAmC,IAAnC,IAA2CL,EAAE,KAAK,KAAK,CAAvD,GAA2DA,EAA3D,GAAgE,EAAtF;;IACA,KAAK,MAAMsB,GAAX,IAAkBjC,MAAM,CAAC4B,IAAP,CAAYF,eAAZ,CAAlB,EAAgD;MAC5C,IAAIA,eAAe,CAACO,GAAD,CAAf,CAAqBF,cAAzB,EAAyC;QACrCC,aAAa,CAACC,GAAD,CAAb,GAAqB,CAACrB,EAAE,GAAGH,YAAY,CAACO,UAAnB,MAAmC,IAAnC,IAA2CJ,EAAE,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,EAAE,CAACqB,GAAD,CAA3F;MACH;IACJ;;IACD,IAAIpB,aAAJ,EAAmB;MACf,KAAK,MAAMoB,GAAX,IAAkBjC,MAAM,CAAC4B,IAAP,CAAYf,aAAZ,CAAlB,EAA8C;QAC1CmB,aAAa,CAACC,GAAD,CAAb,GAAqBpB,aAAa,CAACoB,GAAD,CAAlC;MACH;IACJ;;IACD,OAAOf,UAAU,IACb,CAACT,YAAY,CAACO,UADX,IAEH,CAACH,aAFE,IAGHb,MAAM,CAACK,mBAAP,CAA2BqB,eAA3B,EAA4CpB,MAA5C,KAAuD,CAHpD,GAID,IAJC,GAKD0B,aALN;EAMH;;EACD,OAAOnC,sCAAsC,CAAC;IAC1CM,IAAI,EAAEM,YAAY,CAACO,UADuB;IAE1Cd,OAAO,EAAEW,aAFiC;IAG1CT,eAAe,EAAEc,UAHyB;IAI1CX,cAAc,EAAErB,eAAe,CAACuB,YAAY,CAACO,UAAd,EAA0BK,oBAA1B;EAJW,CAAD,CAA7C;AAMH"},"metadata":{},"sourceType":"module"}