{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\n\nfunction isNodeReadableStream(body) {\n  return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\n\n\nfunction isReadableStream(body) {\n  return Boolean(body && typeof body.getReader === \"function\" && typeof body.tee === \"function\");\n}\n/**\n * Checks if the body is a Blob or Blob-like\n */\n\n\nfunction isBlob(body) {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\n\n\nclass FetchHttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  sendRequest(request) {\n    return _asyncToGenerator(function* () {\n      const url = new URL(request.url);\n      const isInsecure = url.protocol !== \"https:\";\n\n      if (isInsecure && !request.allowInsecureConnection) {\n        throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n      }\n\n      if (request.proxySettings) {\n        throw new Error(\"HTTP proxy is not supported in browser environment\");\n      }\n\n      try {\n        return yield makeRequest(request);\n      } catch (e) {\n        throw getError(e, request);\n      }\n    })();\n  }\n\n}\n/**\n * Sends a request\n */\n\n\nfunction makeRequest(_x) {\n  return _makeRequest.apply(this, arguments);\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\n\n\nfunction _makeRequest() {\n  _makeRequest = _asyncToGenerator(function* (request) {\n    const {\n      abortController,\n      abortControllerCleanup\n    } = setupAbortSignal(request);\n\n    try {\n      const headers = buildFetchHeaders(request.headers);\n      const {\n        streaming,\n        body: requestBody\n      } = buildRequestBody(request);\n      const requestInit = {\n        body: requestBody,\n        method: request.method,\n        headers: headers,\n        signal: abortController.signal,\n        credentials: request.withCredentials ? \"include\" : \"same-origin\",\n        cache: \"no-store\"\n      }; // According to https://fetch.spec.whatwg.org/#fetch-method,\n      // init.duplex must be set when body is a ReadableStream object.\n      // currently \"half\" is the only valid value.\n\n      if (streaming) {\n        requestInit.duplex = \"half\";\n      }\n      /**\n       * Developers of the future:\n       * Do not set redirect: \"manual\" as part\n       * of request options.\n       * It will not work as you expect.\n       */\n\n\n      const response = yield fetch(request.url, requestInit); // If we're uploading a blob, we need to fire the progress event manually\n\n      if (isBlob(request.body) && request.onUploadProgress) {\n        request.onUploadProgress({\n          loadedBytes: request.body.size\n        });\n      }\n\n      return buildPipelineResponse(response, request);\n    } finally {\n      if (abortControllerCleanup) {\n        abortControllerCleanup();\n      }\n    }\n  });\n  return _makeRequest.apply(this, arguments);\n}\n\nfunction buildPipelineResponse(_x2, _x3) {\n  return _buildPipelineResponse.apply(this, arguments);\n}\n\nfunction _buildPipelineResponse() {\n  _buildPipelineResponse = _asyncToGenerator(function* (httpResponse, request) {\n    var _a, _b;\n\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n      request,\n      headers,\n      status: httpResponse.status\n    };\n    const bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;\n\n    if ( // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n      if (request.enableBrowserStreams) {\n        response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n      } else {\n        const responseStream = new Response(bodyStream);\n        response.blobBody = responseStream.blob();\n      }\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.bodyAsText = yield responseStream.text();\n    }\n\n    return response;\n  });\n  return _buildPipelineResponse.apply(this, arguments);\n}\n\nfunction setupAbortSignal(request) {\n  const abortController = new AbortController(); // Cleanup function\n\n  let abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n\n  let abortListener;\n\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n\n    abortListener = event => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n\n    abortControllerCleanup = () => {\n      var _a;\n\n      if (abortListener) {\n        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  } // If a timeout was passed, call the abort signal once the time elapses\n\n\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return {\n    abortController,\n    abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\n\n\nfunction getError(e, request) {\n  var _a;\n\n  if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n      request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\n\n\nfunction buildFetchHeaders(pipelineHeaders) {\n  const headers = new Headers();\n\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse) {\n  const responseHeaders = createHttpHeaders();\n\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\nfunction buildRequestBody(request) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isReadableStream(body) ? {\n    streaming: true,\n    body: buildBodyStream(body, request.onUploadProgress)\n  } : {\n    streaming: false,\n    body\n  };\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\n\n\nfunction buildBodyStream(readableStream, onProgress) {\n  let loadedBytes = 0; // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      }\n\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      pull(controller) {\n        return _asyncToGenerator(function* () {\n          var _a;\n\n          const {\n            done,\n            value\n          } = yield reader.read(); // When no more data needs to be consumed, break the reading\n\n          if (done || !value) {\n            // Close the stream\n            controller.close();\n            reader.releaseLock();\n            return;\n          }\n\n          loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0; // Enqueue the next data chunk into our target stream\n\n          controller.enqueue(value);\n\n          if (onProgress) {\n            onProgress({\n              loadedBytes\n            });\n          }\n        })();\n      }\n\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\n\n\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","body","pipe","isReadableStream","Boolean","getReader","tee","isBlob","Blob","FetchHttpClient","sendRequest","request","url","URL","isInsecure","protocol","allowInsecureConnection","Error","proxySettings","makeRequest","e","getError","abortController","abortControllerCleanup","setupAbortSignal","headers","buildFetchHeaders","streaming","requestBody","buildRequestBody","requestInit","method","signal","credentials","withCredentials","cache","duplex","response","fetch","onUploadProgress","loadedBytes","size","buildPipelineResponse","httpResponse","_a","_b","buildPipelineHeaders","status","bodyStream","buildBodyStream","onDownloadProgress","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","enableBrowserStreams","browserStreamBody","undefined","responseStream","Response","blobBody","blob","bodyAsText","text","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","value","append","responseHeaders","set","readableStream","onProgress","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","reader","ReadableStream","pull","done","read","close","releaseLock","createFetchHttpClient","self"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body) {\n    return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body) {\n    return Boolean(body &&\n        typeof body.getReader === \"function\" &&\n        typeof body.tee === \"function\");\n}\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n    // File objects count as a type of Blob, so we want to use instanceof explicitly\n    return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n    /**\n     * Makes a request over an underlying transport layer and returns the response.\n     * @param request - The request to be made.\n     */\n    async sendRequest(request) {\n        const url = new URL(request.url);\n        const isInsecure = url.protocol !== \"https:\";\n        if (isInsecure && !request.allowInsecureConnection) {\n            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n        }\n        if (request.proxySettings) {\n            throw new Error(\"HTTP proxy is not supported in browser environment\");\n        }\n        try {\n            return await makeRequest(request);\n        }\n        catch (e) {\n            throw getError(e, request);\n        }\n    }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n    const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n    try {\n        const headers = buildFetchHeaders(request.headers);\n        const { streaming, body: requestBody } = buildRequestBody(request);\n        const requestInit = {\n            body: requestBody,\n            method: request.method,\n            headers: headers,\n            signal: abortController.signal,\n            credentials: request.withCredentials ? \"include\" : \"same-origin\",\n            cache: \"no-store\",\n        };\n        // According to https://fetch.spec.whatwg.org/#fetch-method,\n        // init.duplex must be set when body is a ReadableStream object.\n        // currently \"half\" is the only valid value.\n        if (streaming) {\n            requestInit.duplex = \"half\";\n        }\n        /**\n         * Developers of the future:\n         * Do not set redirect: \"manual\" as part\n         * of request options.\n         * It will not work as you expect.\n         */\n        const response = await fetch(request.url, requestInit);\n        // If we're uploading a blob, we need to fire the progress event manually\n        if (isBlob(request.body) && request.onUploadProgress) {\n            request.onUploadProgress({ loadedBytes: request.body.size });\n        }\n        return buildPipelineResponse(response, request);\n    }\n    finally {\n        if (abortControllerCleanup) {\n            abortControllerCleanup();\n        }\n    }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request) {\n    var _a, _b;\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n        request,\n        headers,\n        status: httpResponse.status,\n    };\n    const bodyStream = isReadableStream(httpResponse.body)\n        ? buildBodyStream(httpResponse.body, request.onDownloadProgress)\n        : httpResponse.body;\n    if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) ||\n        ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n        if (request.enableBrowserStreams) {\n            response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n        }\n        else {\n            const responseStream = new Response(bodyStream);\n            response.blobBody = responseStream.blob();\n        }\n    }\n    else {\n        const responseStream = new Response(bodyStream);\n        response.bodyAsText = await responseStream.text();\n    }\n    return response;\n}\nfunction setupAbortSignal(request) {\n    const abortController = new AbortController();\n    // Cleanup function\n    let abortControllerCleanup;\n    /**\n     * Attach an abort listener to the request\n     */\n    let abortListener;\n    if (request.abortSignal) {\n        if (request.abortSignal.aborted) {\n            throw new AbortError(\"The operation was aborted.\");\n        }\n        abortListener = (event) => {\n            if (event.type === \"abort\") {\n                abortController.abort();\n            }\n        };\n        request.abortSignal.addEventListener(\"abort\", abortListener);\n        abortControllerCleanup = () => {\n            var _a;\n            if (abortListener) {\n                (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n            }\n        };\n    }\n    // If a timeout was passed, call the abort signal once the time elapses\n    if (request.timeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n        }, request.timeout);\n    }\n    return { abortController, abortControllerCleanup };\n}\n/**\n * Gets the specific error\n */\nfunction getError(e, request) {\n    var _a;\n    if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n        return e;\n    }\n    else {\n        return new RestError(`Error sending request: ${e.message}`, {\n            code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n            request,\n        });\n    }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n    const headers = new Headers();\n    for (const [name, value] of pipelineHeaders) {\n        headers.append(name, value);\n    }\n    return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n    const responseHeaders = createHttpHeaders();\n    for (const [name, value] of httpResponse.headers) {\n        responseHeaders.set(name, value);\n    }\n    return responseHeaders;\n}\nfunction buildRequestBody(request) {\n    const body = typeof request.body === \"function\" ? request.body() : request.body;\n    if (isNodeReadableStream(body)) {\n        throw new Error(\"Node streams are not supported in browser environment.\");\n    }\n    return isReadableStream(body)\n        ? { streaming: true, body: buildBodyStream(body, request.onUploadProgress) }\n        : { streaming: false, body };\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, onProgress) {\n    let loadedBytes = 0;\n    // If the current browser supports pipeThrough we use a TransformStream\n    // to report progress\n    if (isTransformStreamSupported(readableStream)) {\n        return readableStream.pipeThrough(new TransformStream({\n            transform(chunk, controller) {\n                if (chunk === null) {\n                    controller.terminate();\n                    return;\n                }\n                controller.enqueue(chunk);\n                loadedBytes += chunk.length;\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n        }));\n    }\n    else {\n        // If we can't use transform streams, wrap the original stream in a new readable stream\n        // and use pull to enqueue each chunk and report progress.\n        const reader = readableStream.getReader();\n        return new ReadableStream({\n            async pull(controller) {\n                var _a;\n                const { done, value } = await reader.read();\n                // When no more data needs to be consumed, break the reading\n                if (done || !value) {\n                    // Close the stream\n                    controller.close();\n                    reader.releaseLock();\n                    return;\n                }\n                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n                // Enqueue the next data chunk into our target stream\n                controller.enqueue(value);\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n        });\n    }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n    return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n    return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}