{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n  DefaultScope: \"/.default\",\n\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\"\n  }\n};\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\n\nexport const authorizeRequestOnTenantChallenge = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (challengeOptions) {\n    const requestOptions = requestToOptions(challengeOptions.request);\n    const challenge = getChallenge(challengeOptions.response);\n\n    if (challenge) {\n      const challengeInfo = parseChallenge(challenge);\n      const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n      const tenantId = extractTenantId(challengeInfo);\n      const accessToken = yield challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), {\n        tenantId\n      }));\n\n      if (!accessToken) {\n        return false;\n      }\n\n      challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);\n      return true;\n    }\n\n    return false;\n  });\n\n  return function authorizeRequestOnTenantChallenge(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\n\nfunction extractTenantId(challengeInfo) {\n  const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  const pathSegments = parsedAuthUri.pathname.split(\"/\");\n  const tenantId = pathSegments[1];\n  return tenantId;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\n\n\nfunction buildScopes(challengeOptions, challengeInfo) {\n  if (!challengeInfo.resource_uri) {\n    return challengeOptions.scopes;\n  }\n\n  const challengeScopes = new URL(challengeInfo.resource_uri);\n  challengeScopes.pathname = Constants.DefaultScope;\n  return [challengeScopes.toString()];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\n\n\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n\n  return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\n\n\nfunction parseChallenge(challenge) {\n  const bearerChallenge = challenge.slice(\"Bearer \".length);\n  const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter(x => x);\n  const keyValuePairs = challengeParts.map(keyValue => (([key, value]) => ({\n    [key]: value\n  }))(keyValue.trim().split(\"=\"))); // Key-value pairs to plain object:\n\n  return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\n\n\nfunction requestToOptions(request) {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout\n    },\n    tracingOptions: request.tracingOptions\n  };\n}","map":{"version":3,"names":["Constants","DefaultScope","HeaderConstants","AUTHORIZATION","authorizeRequestOnTenantChallenge","challengeOptions","requestOptions","requestToOptions","request","challenge","getChallenge","response","challengeInfo","parseChallenge","challengeScopes","buildScopes","tenantId","extractTenantId","accessToken","getAccessToken","Object","assign","headers","set","token","parsedAuthUri","URL","authorization_uri","pathSegments","pathname","split","resource_uri","scopes","toString","get","status","bearerChallenge","slice","length","challengeParts","trim","filter","x","keyValuePairs","map","keyValue","key","value","reduce","a","b","abortSignal","timeout","tracingOptions"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n    DefaultScope: \"/.default\",\n    /**\n     * Defines constants for use with HTTP headers.\n     */\n    HeaderConstants: {\n        /**\n         * The Authorization header.\n         */\n        AUTHORIZATION: \"authorization\",\n    },\n};\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge = async (challengeOptions) => {\n    const requestOptions = requestToOptions(challengeOptions.request);\n    const challenge = getChallenge(challengeOptions.response);\n    if (challenge) {\n        const challengeInfo = parseChallenge(challenge);\n        const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n        const tenantId = extractTenantId(challengeInfo);\n        const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));\n        if (!accessToken) {\n            return false;\n        }\n        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);\n        return true;\n    }\n    return false;\n};\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n    const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n    const pathSegments = parsedAuthUri.pathname.split(\"/\");\n    const tenantId = pathSegments[1];\n    return tenantId;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n    if (!challengeInfo.resource_uri) {\n        return challengeOptions.scopes;\n    }\n    const challengeScopes = new URL(challengeInfo.resource_uri);\n    challengeScopes.pathname = Constants.DefaultScope;\n    return [challengeScopes.toString()];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (response.status === 401 && challenge) {\n        return challenge;\n    }\n    return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n    const bearerChallenge = challenge.slice(\"Bearer \".length);\n    const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter((x) => x);\n    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split(\"=\")));\n    // Key-value pairs to plain object:\n    return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n    return {\n        abortSignal: request.abortSignal,\n        requestOptions: {\n            timeout: request.timeout,\n        },\n        tracingOptions: request.tracingOptions,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}