{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\n\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\n\nfunction defaultAuthorizeRequest(_x) {\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\n\n\nfunction _defaultAuthorizeRequest() {\n  _defaultAuthorizeRequest = _asyncToGenerator(function* (options) {\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions\n    };\n    const accessToken = yield getAccessToken(scopes, getTokenOptions);\n\n    if (accessToken) {\n      options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n  });\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n\n  return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\n\n\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a;\n\n  const {\n    credential,\n    scopes,\n    challengeCallbacks\n  } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = Object.assign({\n    authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge\n  }, challengeCallbacks); // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n\n  const getAccessToken = credential ? createTokenCycler(credential\n  /* , options */\n  ) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n\n        yield callbacks.authorizeRequest({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          getAccessToken,\n          logger\n        });\n        let response;\n        let error;\n\n        try {\n          response = yield next(request);\n        } catch (err) {\n          error = err;\n          response = err.response;\n        }\n\n        if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {\n          // processes challenge\n          const shouldSendRequest = yield callbacks.authorizeRequestOnChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            response,\n            getAccessToken,\n            logger\n          });\n\n          if (shouldSendRequest) {\n            return next(request);\n          }\n        }\n\n        if (error) {\n          throw error;\n        } else {\n          return response;\n        }\n      })();\n    }\n\n  };\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","bearerTokenAuthenticationPolicyName","defaultAuthorizeRequest","options","scopes","getAccessToken","request","getTokenOptions","abortSignal","tracingOptions","accessToken","headers","set","token","getChallenge","response","challenge","get","status","bearerTokenAuthenticationPolicy","_a","credential","challengeCallbacks","callbacks","Object","assign","authorizeRequest","authorizeRequestOnChallenge","Promise","resolve","name","sendRequest","next","url","toLowerCase","startsWith","Error","Array","isArray","error","err","shouldSendRequest"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n    const { scopes, getAccessToken, request } = options;\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n    };\n    const accessToken = await getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n        options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (response.status === 401 && challenge) {\n        return challenge;\n    }\n    return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n    var _a;\n    const { credential, scopes, challengeCallbacks } = options;\n    const logger = options.logger || coreLogger;\n    const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);\n    // This function encapsulates the entire process of reliably retrieving the token\n    // The options are left out of the public API until there's demand to configure this.\n    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n    // in order to pass through the `options` object.\n    const getAccessToken = credential\n        ? createTokenCycler(credential /* , options */)\n        : () => Promise.resolve(null);\n    return {\n        name: bearerTokenAuthenticationPolicyName,\n        /**\n         * If there's no challenge parameter:\n         * - It will try to retrieve the token using the cache, or the credential's getToken.\n         * - Then it will try the next policy with or without the retrieved token.\n         *\n         * It uses the challenge parameters to:\n         * - Skip a first attempt to get the token from the credential if there's no cached token,\n         *   since it expects the token to be retrievable only after the challenge.\n         * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n         * - Send an initial request to receive the challenge if it fails.\n         * - Process a challenge if the response contains it.\n         * - Retrieve a token with the challenge information, then re-send the request.\n         */\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            await callbacks.authorizeRequest({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request,\n                getAccessToken,\n                logger,\n            });\n            let response;\n            let error;\n            try {\n                response = await next(request);\n            }\n            catch (err) {\n                error = err;\n                response = err.response;\n            }\n            if (callbacks.authorizeRequestOnChallenge &&\n                (response === null || response === void 0 ? void 0 : response.status) === 401 &&\n                getChallenge(response)) {\n                // processes challenge\n                const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n                    scopes: Array.isArray(scopes) ? scopes : [scopes],\n                    request,\n                    response,\n                    getAccessToken,\n                    logger,\n                });\n                if (shouldSendRequest) {\n                    return next(request);\n                }\n            }\n            if (error) {\n                throw error;\n            }\n            else {\n                return response;\n            }\n        },\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}