{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nconst ValidPhaseNames = new Set([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\n\nclass HttpPipeline {\n  constructor(policies) {\n    var _a;\n\n    this._policies = [];\n    this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];\n    this._orderedPolicies = undefined;\n  }\n\n  addPolicy(policy, options = {}) {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n\n    this._policies.push({\n      policy,\n      options\n    });\n\n    this._orderedPolicies = undefined;\n  }\n\n  removePolicy(options) {\n    const removedPolicies = [];\n    this._policies = this._policies.filter(policyDescriptor => {\n      if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n    return removedPolicies;\n  }\n\n  sendRequest(httpClient, request) {\n    const policies = this.getOrderedPolicies();\n    const pipeline = policies.reduceRight((next, policy) => {\n      return req => {\n        return policy.sendRequest(req, next);\n      };\n    }, req => httpClient.sendRequest(req));\n    return pipeline(request);\n  }\n\n  getOrderedPolicies() {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n\n    return this._orderedPolicies;\n  }\n\n  clone() {\n    return new HttpPipeline(this._policies);\n  }\n\n  static create() {\n    return new HttpPipeline();\n  }\n\n  orderPolicies() {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result = []; // Track all policies we know about.\n\n    const policyMap = new Map();\n\n    function createPhase(name) {\n      return {\n        name,\n        policies: new Set(),\n        hasRun: false,\n        hasAfterPolicies: false\n      };\n    } // Track policies for each phase.\n\n\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\"); // a list of phases in order\n\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase]; // Small helper function to map phase name to each Phase\n\n    function getPhase(phase) {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    } // First walk each policy and create a node to track metadata.\n\n\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n\n      const node = {\n        policy,\n        dependsOn: new Set(),\n        dependants: new Set()\n      };\n\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    } // Now that each policy has a node, connect dependency references.\n\n\n    for (const descriptor of this._policies) {\n      const {\n        policy,\n        options\n      } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase) {\n      phase.hasRun = true; // Sets iterate in insertion order\n\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy); // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n\n    function walkPhases() {\n      for (const phase of orderedPhases) {\n        walkPhase(phase); // if the phase isn't complete\n\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          } // Don't proceed to the next phase until this phase finishes.\n\n\n          return;\n        }\n\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    } // Iterate until we've put every node in the result list.\n\n\n    let iteration = 0;\n\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length; // Keep walking each phase in order until we can order every node.\n\n      walkPhases(); // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n\n}\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\n\n\nexport function createEmptyPipeline() {\n  return HttpPipeline.create();\n}","map":{"version":3,"names":["ValidPhaseNames","Set","HttpPipeline","constructor","policies","_a","_policies","slice","_orderedPolicies","undefined","addPolicy","policy","options","phase","afterPhase","Error","has","push","removePolicy","removedPolicies","filter","policyDescriptor","name","sendRequest","httpClient","request","getOrderedPolicies","pipeline","reduceRight","next","req","orderPolicies","clone","create","result","policyMap","Map","createPhase","hasRun","hasAfterPolicies","serializePhase","noPhase","deserializePhase","retryPhase","signPhase","orderedPhases","getPhase","descriptor","policyName","node","dependsOn","dependants","set","add","get","afterPolicies","afterPolicyName","afterNode","beforePolicies","beforePolicyName","beforeNode","walkPhase","size","dependant","delete","walkPhases","iteration","initialResultLength","length","createEmptyPipeline"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nconst ValidPhaseNames = new Set([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline {\n    constructor(policies) {\n        var _a;\n        this._policies = [];\n        this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];\n        this._orderedPolicies = undefined;\n    }\n    addPolicy(policy, options = {}) {\n        if (options.phase && options.afterPhase) {\n            throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n        }\n        if (options.phase && !ValidPhaseNames.has(options.phase)) {\n            throw new Error(`Invalid phase name: ${options.phase}`);\n        }\n        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n            throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n        }\n        this._policies.push({\n            policy,\n            options,\n        });\n        this._orderedPolicies = undefined;\n    }\n    removePolicy(options) {\n        const removedPolicies = [];\n        this._policies = this._policies.filter((policyDescriptor) => {\n            if ((options.name && policyDescriptor.policy.name === options.name) ||\n                (options.phase && policyDescriptor.options.phase === options.phase)) {\n                removedPolicies.push(policyDescriptor.policy);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n        this._orderedPolicies = undefined;\n        return removedPolicies;\n    }\n    sendRequest(httpClient, request) {\n        const policies = this.getOrderedPolicies();\n        const pipeline = policies.reduceRight((next, policy) => {\n            return (req) => {\n                return policy.sendRequest(req, next);\n            };\n        }, (req) => httpClient.sendRequest(req));\n        return pipeline(request);\n    }\n    getOrderedPolicies() {\n        if (!this._orderedPolicies) {\n            this._orderedPolicies = this.orderPolicies();\n        }\n        return this._orderedPolicies;\n    }\n    clone() {\n        return new HttpPipeline(this._policies);\n    }\n    static create() {\n        return new HttpPipeline();\n    }\n    orderPolicies() {\n        /**\n         * The goal of this method is to reliably order pipeline policies\n         * based on their declared requirements when they were added.\n         *\n         * Order is first determined by phase:\n         *\n         * 1. Serialize Phase\n         * 2. Policies not in a phase\n         * 3. Deserialize Phase\n         * 4. Retry Phase\n         * 5. Sign Phase\n         *\n         * Within each phase, policies are executed in the order\n         * they were added unless they were specified to execute\n         * before/after other policies or after a particular phase.\n         *\n         * To determine the final order, we will walk the policy list\n         * in phase order multiple times until all dependencies are\n         * satisfied.\n         *\n         * `afterPolicies` are the set of policies that must be\n         * executed before a given policy. This requirement is\n         * considered satisfied when each of the listed policies\n         * have been scheduled.\n         *\n         * `beforePolicies` are the set of policies that must be\n         * executed after a given policy. Since this dependency\n         * can be expressed by converting it into a equivalent\n         * `afterPolicies` declarations, they are normalized\n         * into that form for simplicity.\n         *\n         * An `afterPhase` dependency is considered satisfied when all\n         * policies in that phase have scheduled.\n         *\n         */\n        const result = [];\n        // Track all policies we know about.\n        const policyMap = new Map();\n        function createPhase(name) {\n            return {\n                name,\n                policies: new Set(),\n                hasRun: false,\n                hasAfterPolicies: false,\n            };\n        }\n        // Track policies for each phase.\n        const serializePhase = createPhase(\"Serialize\");\n        const noPhase = createPhase(\"None\");\n        const deserializePhase = createPhase(\"Deserialize\");\n        const retryPhase = createPhase(\"Retry\");\n        const signPhase = createPhase(\"Sign\");\n        // a list of phases in order\n        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n        // Small helper function to map phase name to each Phase\n        function getPhase(phase) {\n            if (phase === \"Retry\") {\n                return retryPhase;\n            }\n            else if (phase === \"Serialize\") {\n                return serializePhase;\n            }\n            else if (phase === \"Deserialize\") {\n                return deserializePhase;\n            }\n            else if (phase === \"Sign\") {\n                return signPhase;\n            }\n            else {\n                return noPhase;\n            }\n        }\n        // First walk each policy and create a node to track metadata.\n        for (const descriptor of this._policies) {\n            const policy = descriptor.policy;\n            const options = descriptor.options;\n            const policyName = policy.name;\n            if (policyMap.has(policyName)) {\n                throw new Error(\"Duplicate policy names not allowed in pipeline\");\n            }\n            const node = {\n                policy,\n                dependsOn: new Set(),\n                dependants: new Set(),\n            };\n            if (options.afterPhase) {\n                node.afterPhase = getPhase(options.afterPhase);\n                node.afterPhase.hasAfterPolicies = true;\n            }\n            policyMap.set(policyName, node);\n            const phase = getPhase(options.phase);\n            phase.policies.add(node);\n        }\n        // Now that each policy has a node, connect dependency references.\n        for (const descriptor of this._policies) {\n            const { policy, options } = descriptor;\n            const policyName = policy.name;\n            const node = policyMap.get(policyName);\n            if (!node) {\n                throw new Error(`Missing node for policy ${policyName}`);\n            }\n            if (options.afterPolicies) {\n                for (const afterPolicyName of options.afterPolicies) {\n                    const afterNode = policyMap.get(afterPolicyName);\n                    if (afterNode) {\n                        // Linking in both directions helps later\n                        // when we want to notify dependants.\n                        node.dependsOn.add(afterNode);\n                        afterNode.dependants.add(node);\n                    }\n                }\n            }\n            if (options.beforePolicies) {\n                for (const beforePolicyName of options.beforePolicies) {\n                    const beforeNode = policyMap.get(beforePolicyName);\n                    if (beforeNode) {\n                        // To execute before another node, make it\n                        // depend on the current node.\n                        beforeNode.dependsOn.add(node);\n                        node.dependants.add(beforeNode);\n                    }\n                }\n            }\n        }\n        function walkPhase(phase) {\n            phase.hasRun = true;\n            // Sets iterate in insertion order\n            for (const node of phase.policies) {\n                if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n                    // If this node is waiting on a phase to complete,\n                    // we need to skip it for now.\n                    // Even if the phase is empty, we should wait for it\n                    // to be walked to avoid re-ordering policies.\n                    continue;\n                }\n                if (node.dependsOn.size === 0) {\n                    // If there's nothing else we're waiting for, we can\n                    // add this policy to the result list.\n                    result.push(node.policy);\n                    // Notify anything that depends on this policy that\n                    // the policy has been scheduled.\n                    for (const dependant of node.dependants) {\n                        dependant.dependsOn.delete(node);\n                    }\n                    policyMap.delete(node.policy.name);\n                    phase.policies.delete(node);\n                }\n            }\n        }\n        function walkPhases() {\n            for (const phase of orderedPhases) {\n                walkPhase(phase);\n                // if the phase isn't complete\n                if (phase.policies.size > 0 && phase !== noPhase) {\n                    if (!noPhase.hasRun) {\n                        // Try running noPhase to see if that unblocks this phase next tick.\n                        // This can happen if a phase that happens before noPhase\n                        // is waiting on a noPhase policy to complete.\n                        walkPhase(noPhase);\n                    }\n                    // Don't proceed to the next phase until this phase finishes.\n                    return;\n                }\n                if (phase.hasAfterPolicies) {\n                    // Run any policies unblocked by this phase\n                    walkPhase(noPhase);\n                }\n            }\n        }\n        // Iterate until we've put every node in the result list.\n        let iteration = 0;\n        while (policyMap.size > 0) {\n            iteration++;\n            const initialResultLength = result.length;\n            // Keep walking each phase in order until we can order every node.\n            walkPhases();\n            // The result list *should* get at least one larger each time\n            // after the first full pass.\n            // Otherwise, we're going to loop forever.\n            if (result.length <= initialResultLength && iteration > 1) {\n                throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n            }\n        }\n        return result;\n    }\n}\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline() {\n    return HttpPipeline.create();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}