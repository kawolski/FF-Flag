{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as base64 from \"./base64\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces\";\nimport { isDuration, isValidUuid } from \"./utils\";\n\nclass SerializerImpl {\n  constructor(modelMappers = {}, isXML = false) {\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n  /**\n   * @deprecated Removing the constraints validation on client side.\n   */\n\n\n  validateConstraints(mapper, value, objectName) {\n    const failValidation = (constraintName, constraintValue) => {\n      throw new Error(`\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`);\n    };\n\n    if (mapper.constraints && value !== undefined && value !== null) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems\n      } = mapper.constraints;\n\n      if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n\n      if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n\n      if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n\n      if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n\n      if (MaxItems !== undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n\n      if (MaxLength !== undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n\n      if (MinItems !== undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n\n      if (MinLength !== undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n\n      if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n\n      if (Pattern) {\n        const pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n\n      if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param object - A valid Javascript object to be serialized\n   *\n   * @param objectName - Name of the serialized object\n   *\n   * @param options - additional options to serialization\n   *\n   * @returns A valid serialized Javascript object\n   */\n\n\n  serialize(mapper, object, objectName, options = {\n    xml: {}\n  }) {\n    var _a, _b, _c;\n\n    const updatedOptions = {\n      xml: {\n        rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n        includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n        xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n      }\n    };\n    let payload = {};\n    const mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    } // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n\n    const {\n      required,\n      nullable\n    } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n\n    if (required && !nullable && (object === undefined || object === null)) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object === undefined || object === null) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper = mapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      }\n    }\n\n    return payload;\n  }\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param responseBody - A valid Javascript entity to be deserialized\n   *\n   * @param objectName - Name of the deserialized object\n   *\n   * @param options - Controls behavior of XML parser and builder.\n   *\n   * @returns A valid deserialized Javascript object\n   */\n\n\n  deserialize(mapper, responseBody, objectName, options = {\n    xml: {}\n  }) {\n    var _a, _b, _c, _d;\n\n    const updatedOptions = {\n      xml: {\n        rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n        includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n        xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n      },\n      ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false\n    };\n\n    if (responseBody === undefined || responseBody === null) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      } // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n\n\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n\n      return responseBody;\n    }\n\n    let payload;\n    const mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xml.xmlCharKey;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n\n        if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n          responseBody = responseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody);\n\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n\n}\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\n\n\nexport function createSerializer(modelMappers = {}, isXML = false) {\n  return new SerializerImpl(modelMappers, isXML);\n}\n\nfunction trimEnd(str, ch) {\n  let len = str.length;\n\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  } // Uint8Array to Base64.\n\n\n  const str = base64.encodeByteArray(buffer); // Base64 to Base64Url.\n\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  } // Base64Url to Base64.\n\n\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\"); // Base64 to Uint8Array.\n\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop) {\n  const classes = [];\n  let partialclass = \"\";\n\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n\n  return Math.floor(d.getTime() / 1000);\n}\n\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string and a valid uuid.`);\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n\n      if (objectType !== \"string\" && typeof value.pipe !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly\n      !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) && objectType !== \"function\") {\n        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream.`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);\n  }\n\n  const isPresent = allowedValues.some(item => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n\n    return item === value;\n  });\n\n  if (!isPresent) {\n    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);\n  }\n\n  return value;\n}\n\nfunction serializeByteArrayType(objectName, value) {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n\n    value = base64.encodeByteArray(value);\n  }\n\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName, value) {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n\n    value = bufferToBase64Url(value);\n  }\n\n  return value;\n}\n\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value !== undefined && value !== null) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);\n      }\n\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!isDuration(value)) {\n        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n  var _a;\n\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n\n  let elementType = mapper.type.element;\n\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(`element\" metadata for an Array must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}.`);\n  } // Quirk: Composite mappers referenced by `element` might\n  // not have *all* properties declared (like uberParent),\n  // so let's try to look up the full definition by name.\n\n\n  if (elementType.type.name === \"Composite\" && elementType.type.className) {\n    elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;\n  }\n\n  const tempArray = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : \"xmlns\";\n\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = Object.assign({}, serializedValue);\n        tempArray[i][XML_ATTRKEY] = {\n          [xmlnsKey]: elementType.xmlNamespace\n        };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xml.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = {\n          [xmlnsKey]: elementType.xmlNamespace\n        };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n\n  return tempArray;\n}\n\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n\n  const valueType = mapper.type.value;\n\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}.`);\n  }\n\n  const tempDictionary = {};\n\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options); // If the element needs an XML namespace we need to add it within the $ property\n\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  } // Add the namespace to the root element if needed\n\n\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: mapper.xmlNamespace\n    };\n    return result;\n  }\n\n  return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\n\n\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\n\n\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n  const className = mapper.type.className;\n\n  if (!className) {\n    throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper, undefined, 2)}\".`);\n  }\n\n  return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\n\n\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  let modelProps = mapper.type.modelProperties;\n\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n\n    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n\n    if (!modelProps) {\n      throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for object \"${objectName}\".`);\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object !== undefined && object !== null) {\n    const payload = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName;\n      let parentObject = payload;\n\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n\n          if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {\n            parentObject[pathName] = {};\n          }\n\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject !== undefined && parentObject !== null) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n          parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), {\n            [xmlnsKey]: mapper.xmlNamespace\n          });\n        }\n\n        const propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n\n        if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = {\n              [propertyMapper.xmlElementName]: value\n            };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every(pn => pn !== clientPropName);\n\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n        }\n      }\n    }\n\n    return payload;\n  }\n\n  return object;\n}\n\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : \"xmlns\";\n  const xmlNamespace = {\n    [xmlnsKey]: propertyMapper.xmlNamespace\n  };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result = Object.assign({}, serializedValue);\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n\n  const result = {};\n  result[options.xml.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName, options) {\n  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n  var _a, _b;\n\n  const xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance = {};\n  const handledPropertyNames = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    const {\n      serializedName,\n      xmlName,\n      xmlElementName\n    } = propertyMapper;\n    let propertyObjectName = objectName;\n\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n\n    if (headerCollectionPrefix) {\n      const dictionary = {};\n\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName];\n          const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];\n          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n          handledPropertyNames.push(xmlName);\n        } else {\n          const property = responseBody[propertyName];\n          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n          handledPropertyNames.push(propertyName);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody; // traversing the object step by step.\n\n      let steps = 0;\n\n      for (const item of paths) {\n        if (!res) break;\n        steps++;\n        res = res[item];\n      } // only accept null when reaching the last position of object otherwise it would be undefined\n\n\n      if (res === null && steps < paths.length) {\n        res = undefined;\n      }\n\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator; // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n\n      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue; // paging\n\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options); // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = responsePropName => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n      }\n    }\n  } else if (responseBody && !options.ignoreUnknownProperties) {\n    for (const key of Object.keys(responseBody)) {\n      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n  /* jshint validthis: true */\n  const value = mapper.type.value;\n\n  if (!value || typeof value !== \"object\") {\n    throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}`);\n  }\n\n  if (responseBody) {\n    const tempDictionary = {};\n\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n\n    return tempDictionary;\n  }\n\n  return responseBody;\n}\n\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n  var _a;\n\n  let element = mapper.type.element;\n\n  if (!element || typeof element !== \"object\") {\n    throw new Error(`element\" metadata for an Array must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}`);\n  }\n\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    } // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n\n\n    if (element.type.name === \"Composite\" && element.type.className) {\n      element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;\n    }\n\n    const tempArray = [];\n\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);\n    }\n\n    return tempArray;\n  }\n\n  return responseBody;\n}\n\nfunction getIndexDiscriminator(discriminators, discriminatorValue, typeName) {\n  const typeNamesToCheck = [typeName];\n\n  while (typeNamesToCheck.length) {\n    const currentName = typeNamesToCheck.shift();\n    const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + \".\" + discriminatorValue;\n\n    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n      return discriminators[indexDiscriminator];\n    } else {\n      for (const [name, mapper] of Object.entries(discriminators)) {\n        if (name.startsWith(currentName + \".\") && mapper.type.uberParent === currentName && mapper.type.className) {\n          typeNamesToCheck.push(mapper.type.className);\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  var _a;\n\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n  if (polymorphicDiscriminator) {\n    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n\n    if (discriminatorName) {\n      // The serializedName might have \\\\, which we just want to ignore\n      if (polymorphicPropertyName === \"serializedName\") {\n        discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n      }\n\n      const discriminatorValue = object[discriminatorName];\n      const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;\n\n      if (typeof discriminatorValue === \"string\" && typeName) {\n        const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);\n\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n}\n/**\n * Known types of Mappers\n */\n\n\nexport const MapperTypeNames = {\n  Base64Url: \"Base64Url\",\n  Boolean: \"Boolean\",\n  ByteArray: \"ByteArray\",\n  Composite: \"Composite\",\n  Date: \"Date\",\n  DateTime: \"DateTime\",\n  DateTimeRfc1123: \"DateTimeRfc1123\",\n  Dictionary: \"Dictionary\",\n  Enum: \"Enum\",\n  Number: \"Number\",\n  Object: \"Object\",\n  Sequence: \"Sequence\",\n  String: \"String\",\n  Stream: \"Stream\",\n  TimeSpan: \"TimeSpan\",\n  UnixTime: \"UnixTime\"\n};","map":{"version":3,"names":["base64","XML_ATTRKEY","XML_CHARKEY","isDuration","isValidUuid","SerializerImpl","constructor","modelMappers","isXML","validateConstraints","mapper","value","objectName","failValidation","constraintName","constraintValue","Error","constraints","undefined","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","length","pattern","RegExp","match","some","item","i","ar","indexOf","serialize","object","options","xml","_a","_b","_c","updatedOptions","rootName","includeRoot","xmlCharKey","payload","mapperType","type","name","serializedName","isConstant","defaultValue","required","nullable","serializeBasicTypes","enumMapper","serializeEnumType","allowedValues","serializeDateTypes","serializeByteArrayType","serializeBase64UrlType","serializeSequenceType","Boolean","serializeDictionaryType","serializeCompositeType","deserialize","responseBody","_d","ignoreUnknownProperties","xmlIsWrapped","deserializeCompositeType","parseFloat","isNaN","Date","unixTimeToDate","decodeString","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","createSerializer","trimEnd","str","ch","len","substr","bufferToBase64Url","buffer","Uint8Array","encodeByteArray","replace","valueOf","splitSerializeName","prop","classes","partialclass","subwords","split","charAt","push","dateToUnixTime","d","Math","floor","getTime","n","typeName","objectType","pipe","ArrayBuffer","isView","Blob","isPresent","toLowerCase","JSON","stringify","parse","toISOString","substring","toUTCString","serializer","isXml","Array","isArray","elementType","element","className","tempArray","serializedValue","xmlNamespace","xmlnsKey","xmlNamespacePrefix","Object","assign","valueType","tempDictionary","key","keys","getXmlObjectValue","result","resolveAdditionalProperties","additionalProperties","modelMapper","resolveReferencedMapper","resolveModelProperties","modelProps","modelProperties","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","propertyMapper","readOnly","propName","parentObject","xmlName","xmlElementName","paths","pop","pathName","childObject","propertyObjectName","toSerialize","polymorphicDiscriminator","clientName","xmlIsAttribute","additionalPropertiesMapper","propNames","clientPropName","isAdditionalProperty","every","pn","includes","isSpecialXmlProperty","propertyName","instance","handledPropertyNames","headerCollectionPrefix","dictionary","headerKey","startsWith","xmlIsMsText","wrapped","elementList","property","propertyInstance","res","steps","arrayInstance","k","v","entries","prototype","hasOwnProperty","call","responsePropName","getIndexDiscriminator","discriminators","discriminatorValue","typeNamesToCheck","currentName","shift","indexDiscriminator","uberParent","polymorphicPropertyName","discriminatorName","polymorphicMapper","getPolymorphicDiscriminatorSafely","MapperTypeNames","Base64Url","ByteArray","Composite","DateTime","DateTimeRfc1123","Dictionary","Enum","Number","Sequence","String","Stream","TimeSpan","UnixTime"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-client/dist-esm/src/serializer.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as base64 from \"./base64\";\nimport { XML_ATTRKEY, XML_CHARKEY, } from \"./interfaces\";\nimport { isDuration, isValidUuid } from \"./utils\";\nclass SerializerImpl {\n    constructor(modelMappers = {}, isXML = false) {\n        this.modelMappers = modelMappers;\n        this.isXML = isXML;\n    }\n    /**\n     * @deprecated Removing the constraints validation on client side.\n     */\n    validateConstraints(mapper, value, objectName) {\n        const failValidation = (constraintName, constraintValue) => {\n            throw new Error(`\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`);\n        };\n        if (mapper.constraints && value !== undefined && value !== null) {\n            const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems, } = mapper.constraints;\n            if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n                failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n            }\n            if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n                failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n            }\n            if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n                failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n            }\n            if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n                failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n            }\n            if (MaxItems !== undefined && value.length > MaxItems) {\n                failValidation(\"MaxItems\", MaxItems);\n            }\n            if (MaxLength !== undefined && value.length > MaxLength) {\n                failValidation(\"MaxLength\", MaxLength);\n            }\n            if (MinItems !== undefined && value.length < MinItems) {\n                failValidation(\"MinItems\", MinItems);\n            }\n            if (MinLength !== undefined && value.length < MinLength) {\n                failValidation(\"MinLength\", MinLength);\n            }\n            if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n                failValidation(\"MultipleOf\", MultipleOf);\n            }\n            if (Pattern) {\n                const pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n                if (typeof value !== \"string\" || value.match(pattern) === null) {\n                    failValidation(\"Pattern\", Pattern);\n                }\n            }\n            if (UniqueItems &&\n                value.some((item, i, ar) => ar.indexOf(item) !== i)) {\n                failValidation(\"UniqueItems\", UniqueItems);\n            }\n        }\n    }\n    /**\n     * Serialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param object - A valid Javascript object to be serialized\n     *\n     * @param objectName - Name of the serialized object\n     *\n     * @param options - additional options to serialization\n     *\n     * @returns A valid serialized Javascript object\n     */\n    serialize(mapper, object, objectName, options = { xml: {} }) {\n        var _a, _b, _c;\n        const updatedOptions = {\n            xml: {\n                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n            },\n        };\n        let payload = {};\n        const mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Sequence$/i) !== null) {\n            payload = [];\n        }\n        if (mapper.isConstant) {\n            object = mapper.defaultValue;\n        }\n        // This table of allowed values should help explain\n        // the mapper.required and mapper.nullable properties.\n        // X means \"neither undefined or null are allowed\".\n        //           || required\n        //           || true      | false\n        //  nullable || ==========================\n        //      true || null      | undefined/null\n        //     false || X         | undefined\n        // undefined || X         | undefined/null\n        const { required, nullable } = mapper;\n        if (required && nullable && object === undefined) {\n            throw new Error(`${objectName} cannot be undefined.`);\n        }\n        if (required && !nullable && (object === undefined || object === null)) {\n            throw new Error(`${objectName} cannot be null or undefined.`);\n        }\n        if (!required && nullable === false && object === null) {\n            throw new Error(`${objectName} cannot be null.`);\n        }\n        if (object === undefined || object === null) {\n            payload = object;\n        }\n        else {\n            if (mapperType.match(/^any$/i) !== null) {\n                payload = object;\n            }\n            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n                payload = serializeBasicTypes(mapperType, objectName, object);\n            }\n            else if (mapperType.match(/^Enum$/i) !== null) {\n                const enumMapper = mapper;\n                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n            }\n            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n                payload = serializeDateTypes(mapperType, object, objectName);\n            }\n            else if (mapperType.match(/^ByteArray$/i) !== null) {\n                payload = serializeByteArrayType(objectName, object);\n            }\n            else if (mapperType.match(/^Base64Url$/i) !== null) {\n                payload = serializeBase64UrlType(objectName, object);\n            }\n            else if (mapperType.match(/^Sequence$/i) !== null) {\n                payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n            else if (mapperType.match(/^Dictionary$/i) !== null) {\n                payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n            else if (mapperType.match(/^Composite$/i) !== null) {\n                payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n        }\n        return payload;\n    }\n    /**\n     * Deserialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param responseBody - A valid Javascript entity to be deserialized\n     *\n     * @param objectName - Name of the deserialized object\n     *\n     * @param options - Controls behavior of XML parser and builder.\n     *\n     * @returns A valid deserialized Javascript object\n     */\n    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {\n        var _a, _b, _c, _d;\n        const updatedOptions = {\n            xml: {\n                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n            },\n            ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false,\n        };\n        if (responseBody === undefined || responseBody === null) {\n            if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n                // between the list being empty versus being missing,\n                // so let's do the more user-friendly thing and return an empty list.\n                responseBody = [];\n            }\n            // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n            if (mapper.defaultValue !== undefined) {\n                responseBody = mapper.defaultValue;\n            }\n            return responseBody;\n        }\n        let payload;\n        const mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Composite$/i) !== null) {\n            payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n        }\n        else {\n            if (this.isXML) {\n                const xmlCharKey = updatedOptions.xml.xmlCharKey;\n                /**\n                 * If the mapper specifies this as a non-composite type value but the responseBody contains\n                 * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n                 * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n                 */\n                if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n                    responseBody = responseBody[xmlCharKey];\n                }\n            }\n            if (mapperType.match(/^Number$/i) !== null) {\n                payload = parseFloat(responseBody);\n                if (isNaN(payload)) {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^Boolean$/i) !== null) {\n                if (responseBody === \"true\") {\n                    payload = true;\n                }\n                else if (responseBody === \"false\") {\n                    payload = false;\n                }\n                else {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n                payload = responseBody;\n            }\n            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n                payload = new Date(responseBody);\n            }\n            else if (mapperType.match(/^UnixTime$/i) !== null) {\n                payload = unixTimeToDate(responseBody);\n            }\n            else if (mapperType.match(/^ByteArray$/i) !== null) {\n                payload = base64.decodeString(responseBody);\n            }\n            else if (mapperType.match(/^Base64Url$/i) !== null) {\n                payload = base64UrlToByteArray(responseBody);\n            }\n            else if (mapperType.match(/^Sequence$/i) !== null) {\n                payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n            }\n            else if (mapperType.match(/^Dictionary$/i) !== null) {\n                payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n            }\n        }\n        if (mapper.isConstant) {\n            payload = mapper.defaultValue;\n        }\n        return payload;\n    }\n}\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer(modelMappers = {}, isXML = false) {\n    return new SerializerImpl(modelMappers, isXML);\n}\nfunction trimEnd(str, ch) {\n    let len = str.length;\n    while (len - 1 >= 0 && str[len - 1] === ch) {\n        --len;\n    }\n    return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n    if (!buffer) {\n        return undefined;\n    }\n    if (!(buffer instanceof Uint8Array)) {\n        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n    }\n    // Uint8Array to Base64.\n    const str = base64.encodeByteArray(buffer);\n    // Base64 to Base64Url.\n    return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n    if (!str) {\n        return undefined;\n    }\n    if (str && typeof str.valueOf() !== \"string\") {\n        throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n    }\n    // Base64Url to Base64.\n    str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    // Base64 to Uint8Array.\n    return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n    const classes = [];\n    let partialclass = \"\";\n    if (prop) {\n        const subwords = prop.split(\".\");\n        for (const item of subwords) {\n            if (item.charAt(item.length - 1) === \"\\\\\") {\n                partialclass += item.substr(0, item.length - 1) + \".\";\n            }\n            else {\n                partialclass += item;\n                classes.push(partialclass);\n                partialclass = \"\";\n            }\n        }\n    }\n    return classes;\n}\nfunction dateToUnixTime(d) {\n    if (!d) {\n        return undefined;\n    }\n    if (typeof d.valueOf() === \"string\") {\n        d = new Date(d);\n    }\n    return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n    if (!n) {\n        return undefined;\n    }\n    return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n    if (value !== null && value !== undefined) {\n        if (typeName.match(/^Number$/i) !== null) {\n            if (typeof value !== \"number\") {\n                throw new Error(`${objectName} with value ${value} must be of type number.`);\n            }\n        }\n        else if (typeName.match(/^String$/i) !== null) {\n            if (typeof value.valueOf() !== \"string\") {\n                throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n            }\n        }\n        else if (typeName.match(/^Uuid$/i) !== null) {\n            if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n                throw new Error(`${objectName} with value \"${value}\" must be of type string and a valid uuid.`);\n            }\n        }\n        else if (typeName.match(/^Boolean$/i) !== null) {\n            if (typeof value !== \"boolean\") {\n                throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n            }\n        }\n        else if (typeName.match(/^Stream$/i) !== null) {\n            const objectType = typeof value;\n            if (objectType !== \"string\" &&\n                typeof value.pipe !== \"function\" &&\n                !(value instanceof ArrayBuffer) &&\n                !ArrayBuffer.isView(value) &&\n                // File objects count as a type of Blob, so we want to use instanceof explicitly\n                !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) &&\n                objectType !== \"function\") {\n                throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream.`);\n            }\n        }\n    }\n    return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n    if (!allowedValues) {\n        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);\n    }\n    const isPresent = allowedValues.some((item) => {\n        if (typeof item.valueOf() === \"string\") {\n            return item.toLowerCase() === value.toLowerCase();\n        }\n        return item === value;\n    });\n    if (!isPresent) {\n        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);\n    }\n    return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n    if (value !== undefined && value !== null) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(`${objectName} must be of type Uint8Array.`);\n        }\n        value = base64.encodeByteArray(value);\n    }\n    return value;\n}\nfunction serializeBase64UrlType(objectName, value) {\n    if (value !== undefined && value !== null) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(`${objectName} must be of type Uint8Array.`);\n        }\n        value = bufferToBase64Url(value);\n    }\n    return value;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n    if (value !== undefined && value !== null) {\n        if (typeName.match(/^Date$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n            }\n            value =\n                value instanceof Date\n                    ? value.toISOString().substring(0, 10)\n                    : new Date(value).toISOString().substring(0, 10);\n        }\n        else if (typeName.match(/^DateTime$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n            }\n            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n        }\n        else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n            }\n            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n        }\n        else if (typeName.match(/^UnixTime$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n                    `for it to be serialized in UnixTime/Epoch format.`);\n            }\n            value = dateToUnixTime(value);\n        }\n        else if (typeName.match(/^TimeSpan$/i) !== null) {\n            if (!isDuration(value)) {\n                throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`);\n            }\n        }\n    }\n    return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n    var _a;\n    if (!Array.isArray(object)) {\n        throw new Error(`${objectName} must be of type Array.`);\n    }\n    let elementType = mapper.type.element;\n    if (!elementType || typeof elementType !== \"object\") {\n        throw new Error(`element\" metadata for an Array must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}.`);\n    }\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (elementType.type.name === \"Composite\" && elementType.type.className) {\n        elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;\n    }\n    const tempArray = [];\n    for (let i = 0; i < object.length; i++) {\n        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n        if (isXml && elementType.xmlNamespace) {\n            const xmlnsKey = elementType.xmlNamespacePrefix\n                ? `xmlns:${elementType.xmlNamespacePrefix}`\n                : \"xmlns\";\n            if (elementType.type.name === \"Composite\") {\n                tempArray[i] = Object.assign({}, serializedValue);\n                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n            }\n            else {\n                tempArray[i] = {};\n                tempArray[i][options.xml.xmlCharKey] = serializedValue;\n                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n            }\n        }\n        else {\n            tempArray[i] = serializedValue;\n        }\n    }\n    return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n    if (typeof object !== \"object\") {\n        throw new Error(`${objectName} must be of type object.`);\n    }\n    const valueType = mapper.type.value;\n    if (!valueType || typeof valueType !== \"object\") {\n        throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}.`);\n    }\n    const tempDictionary = {};\n    for (const key of Object.keys(object)) {\n        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n        // If the element needs an XML namespace we need to add it within the $ property\n        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n    }\n    // Add the namespace to the root element if needed\n    if (isXml && mapper.xmlNamespace) {\n        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n        const result = tempDictionary;\n        result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n        return result;\n    }\n    return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n    const additionalProperties = mapper.type.additionalProperties;\n    if (!additionalProperties && mapper.type.className) {\n        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n    }\n    return additionalProperties;\n}\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n    const className = mapper.type.className;\n    if (!className) {\n        throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper, undefined, 2)}\".`);\n    }\n    return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n    let modelProps = mapper.type.modelProperties;\n    if (!modelProps) {\n        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n        if (!modelMapper) {\n            throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n        }\n        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n        if (!modelProps) {\n            throw new Error(`modelProperties cannot be null or undefined in the ` +\n                `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for object \"${objectName}\".`);\n        }\n    }\n    return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n    }\n    if (object !== undefined && object !== null) {\n        const payload = {};\n        const modelProps = resolveModelProperties(serializer, mapper, objectName);\n        for (const key of Object.keys(modelProps)) {\n            const propertyMapper = modelProps[key];\n            if (propertyMapper.readOnly) {\n                continue;\n            }\n            let propName;\n            let parentObject = payload;\n            if (serializer.isXML) {\n                if (propertyMapper.xmlIsWrapped) {\n                    propName = propertyMapper.xmlName;\n                }\n                else {\n                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n                }\n            }\n            else {\n                const paths = splitSerializeName(propertyMapper.serializedName);\n                propName = paths.pop();\n                for (const pathName of paths) {\n                    const childObject = parentObject[pathName];\n                    if ((childObject === undefined || childObject === null) &&\n                        ((object[key] !== undefined && object[key] !== null) ||\n                            propertyMapper.defaultValue !== undefined)) {\n                        parentObject[pathName] = {};\n                    }\n                    parentObject = parentObject[pathName];\n                }\n            }\n            if (parentObject !== undefined && parentObject !== null) {\n                if (isXml && mapper.xmlNamespace) {\n                    const xmlnsKey = mapper.xmlNamespacePrefix\n                        ? `xmlns:${mapper.xmlNamespacePrefix}`\n                        : \"xmlns\";\n                    parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });\n                }\n                const propertyObjectName = propertyMapper.serializedName !== \"\"\n                    ? objectName + \".\" + propertyMapper.serializedName\n                    : objectName;\n                let toSerialize = object[key];\n                const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n                if (polymorphicDiscriminator &&\n                    polymorphicDiscriminator.clientName === key &&\n                    (toSerialize === undefined || toSerialize === null)) {\n                    toSerialize = mapper.serializedName;\n                }\n                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n                if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n                    const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n                    if (isXml && propertyMapper.xmlIsAttribute) {\n                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n                        // This keeps things simple while preventing name collision\n                        // with names in user documents.\n                        parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n                        parentObject[XML_ATTRKEY][propName] = serializedValue;\n                    }\n                    else if (isXml && propertyMapper.xmlIsWrapped) {\n                        parentObject[propName] = { [propertyMapper.xmlElementName]: value };\n                    }\n                    else {\n                        parentObject[propName] = value;\n                    }\n                }\n            }\n        }\n        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n        if (additionalPropertiesMapper) {\n            const propNames = Object.keys(modelProps);\n            for (const clientPropName in object) {\n                const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n                if (isAdditionalProperty) {\n                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n                }\n            }\n        }\n        return payload;\n    }\n    return object;\n}\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n    if (!isXml || !propertyMapper.xmlNamespace) {\n        return serializedValue;\n    }\n    const xmlnsKey = propertyMapper.xmlNamespacePrefix\n        ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n        : \"xmlns\";\n    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n    if ([\"Composite\"].includes(propertyMapper.type.name)) {\n        if (serializedValue[XML_ATTRKEY]) {\n            return serializedValue;\n        }\n        else {\n            const result = Object.assign({}, serializedValue);\n            result[XML_ATTRKEY] = xmlNamespace;\n            return result;\n        }\n    }\n    const result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = xmlNamespace;\n    return result;\n}\nfunction isSpecialXmlProperty(propertyName, options) {\n    return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n    var _a, _b;\n    const xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n    }\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    let instance = {};\n    const handledPropertyNames = [];\n    for (const key of Object.keys(modelProps)) {\n        const propertyMapper = modelProps[key];\n        const paths = splitSerializeName(modelProps[key].serializedName);\n        handledPropertyNames.push(paths[0]);\n        const { serializedName, xmlName, xmlElementName } = propertyMapper;\n        let propertyObjectName = objectName;\n        if (serializedName !== \"\" && serializedName !== undefined) {\n            propertyObjectName = objectName + \".\" + serializedName;\n        }\n        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n            const dictionary = {};\n            for (const headerKey of Object.keys(responseBody)) {\n                if (headerKey.startsWith(headerCollectionPrefix)) {\n                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n                }\n                handledPropertyNames.push(headerKey);\n            }\n            instance[key] = dictionary;\n        }\n        else if (serializer.isXML) {\n            if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n                instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n            }\n            else if (propertyMapper.xmlIsMsText) {\n                if (responseBody[xmlCharKey] !== undefined) {\n                    instance[key] = responseBody[xmlCharKey];\n                }\n                else if (typeof responseBody === \"string\") {\n                    // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n                    //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n                    instance[key] = responseBody;\n                }\n            }\n            else {\n                const propertyName = xmlElementName || xmlName || serializedName;\n                if (propertyMapper.xmlIsWrapped) {\n                    /* a list of <xmlElementName> wrapped by <xmlName>\n                      For the xml example below\n                        <Cors>\n                          <CorsRule>...</CorsRule>\n                          <CorsRule>...</CorsRule>\n                        </Cors>\n                      the responseBody has\n                        {\n                          Cors: {\n                            CorsRule: [{...}, {...}]\n                          }\n                        }\n                      xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n                    */\n                    const wrapped = responseBody[xmlName];\n                    const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];\n                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n                    handledPropertyNames.push(xmlName);\n                }\n                else {\n                    const property = responseBody[propertyName];\n                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n                    handledPropertyNames.push(propertyName);\n                }\n            }\n        }\n        else {\n            // deserialize the property if it is present in the provided responseBody instance\n            let propertyInstance;\n            let res = responseBody;\n            // traversing the object step by step.\n            let steps = 0;\n            for (const item of paths) {\n                if (!res)\n                    break;\n                steps++;\n                res = res[item];\n            }\n            // only accept null when reaching the last position of object otherwise it would be undefined\n            if (res === null && steps < paths.length) {\n                res = undefined;\n            }\n            propertyInstance = res;\n            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n            // checking that the model property name (key)(ex: \"fishtype\") and the\n            // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n            // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n            // is a better approach. The generator is not consistent with escaping '\\.' in the\n            // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n            // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n            // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n            // the transformation of model property name (ex: \"fishtype\") is done consistently.\n            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n            if (polymorphicDiscriminator &&\n                key === polymorphicDiscriminator.clientName &&\n                (propertyInstance === undefined || propertyInstance === null)) {\n                propertyInstance = mapper.serializedName;\n            }\n            let serializedValue;\n            // paging\n            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n                propertyInstance = responseBody[key];\n                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n                // Copy over any properties that have already been added into the instance, where they do\n                // not exist on the newly de-serialized array\n                for (const [k, v] of Object.entries(instance)) {\n                    if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n                        arrayInstance[k] = v;\n                    }\n                }\n                instance = arrayInstance;\n            }\n            else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n                instance[key] = serializedValue;\n            }\n        }\n    }\n    const additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n        const isAdditionalProperty = (responsePropName) => {\n            for (const clientPropName in modelProps) {\n                const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n                if (paths[0] === responsePropName) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        for (const responsePropName in responseBody) {\n            if (isAdditionalProperty(responsePropName)) {\n                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n            }\n        }\n    }\n    else if (responseBody && !options.ignoreUnknownProperties) {\n        for (const key of Object.keys(responseBody)) {\n            if (instance[key] === undefined &&\n                !handledPropertyNames.includes(key) &&\n                !isSpecialXmlProperty(key, options)) {\n                instance[key] = responseBody[key];\n            }\n        }\n    }\n    return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n    /* jshint validthis: true */\n    const value = mapper.type.value;\n    if (!value || typeof value !== \"object\") {\n        throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}`);\n    }\n    if (responseBody) {\n        const tempDictionary = {};\n        for (const key of Object.keys(responseBody)) {\n            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n        }\n        return tempDictionary;\n    }\n    return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n    var _a;\n    let element = mapper.type.element;\n    if (!element || typeof element !== \"object\") {\n        throw new Error(`element\" metadata for an Array must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}`);\n    }\n    if (responseBody) {\n        if (!Array.isArray(responseBody)) {\n            // xml2js will interpret a single element array as just the element, so force it to be an array\n            responseBody = [responseBody];\n        }\n        // Quirk: Composite mappers referenced by `element` might\n        // not have *all* properties declared (like uberParent),\n        // so let's try to look up the full definition by name.\n        if (element.type.name === \"Composite\" && element.type.className) {\n            element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;\n        }\n        const tempArray = [];\n        for (let i = 0; i < responseBody.length; i++) {\n            tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);\n        }\n        return tempArray;\n    }\n    return responseBody;\n}\nfunction getIndexDiscriminator(discriminators, discriminatorValue, typeName) {\n    const typeNamesToCheck = [typeName];\n    while (typeNamesToCheck.length) {\n        const currentName = typeNamesToCheck.shift();\n        const indexDiscriminator = discriminatorValue === currentName\n            ? discriminatorValue\n            : currentName + \".\" + discriminatorValue;\n        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n            return discriminators[indexDiscriminator];\n        }\n        else {\n            for (const [name, mapper] of Object.entries(discriminators)) {\n                if (name.startsWith(currentName + \".\") &&\n                    mapper.type.uberParent === currentName &&\n                    mapper.type.className) {\n                    typeNamesToCheck.push(mapper.type.className);\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n    var _a;\n    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n    if (polymorphicDiscriminator) {\n        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n        if (discriminatorName) {\n            // The serializedName might have \\\\, which we just want to ignore\n            if (polymorphicPropertyName === \"serializedName\") {\n                discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n            }\n            const discriminatorValue = object[discriminatorName];\n            const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;\n            if (typeof discriminatorValue === \"string\" && typeName) {\n                const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);\n                if (polymorphicMapper) {\n                    mapper = polymorphicMapper;\n                }\n            }\n        }\n    }\n    return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n    return (mapper.type.polymorphicDiscriminator ||\n        getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n        getPolymorphicDiscriminatorSafely(serializer, mapper.type.className));\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n    return (typeName &&\n        serializer.modelMappers[typeName] &&\n        serializer.modelMappers[typeName].type.polymorphicDiscriminator);\n}\n/**\n * Known types of Mappers\n */\nexport const MapperTypeNames = {\n    Base64Url: \"Base64Url\",\n    Boolean: \"Boolean\",\n    ByteArray: \"ByteArray\",\n    Composite: \"Composite\",\n    Date: \"Date\",\n    DateTime: \"DateTime\",\n    DateTimeRfc1123: \"DateTimeRfc1123\",\n    Dictionary: \"Dictionary\",\n    Enum: \"Enum\",\n    Number: \"Number\",\n    Object: \"Object\",\n    Sequence: \"Sequence\",\n    String: \"String\",\n    Stream: \"Stream\",\n    TimeSpan: \"TimeSpan\",\n    UnixTime: \"UnixTime\",\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}