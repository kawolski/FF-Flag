{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\n\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\n\nexport function retryPolicy(strategies, options = {\n  maxRetries: DEFAULT_RETRY_POLICY_COUNT\n}) {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        var _a, _b;\n\n        let response;\n        let responseError;\n        let retryCount = -1; // eslint-disable-next-line no-constant-condition\n\n        retryRequest: while (true) {\n          retryCount += 1;\n          response = undefined;\n          responseError = undefined;\n\n          try {\n            logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n            response = yield next(request);\n            logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n          } catch (e) {\n            logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId); // RestErrors are valid targets for the retry strategies.\n            // If none of the retry strategies can work with them, they will be thrown later in this policy.\n            // If the received error is not a RestError, it is immediately thrown.\n\n            responseError = e;\n\n            if (!e || responseError.name !== \"RestError\") {\n              throw e;\n            }\n\n            response = responseError.response;\n          }\n\n          if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n            logger.error(`Retry ${retryCount}: Request aborted.`);\n            const abortError = new AbortError();\n            throw abortError;\n          }\n\n          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n            logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n\n            if (responseError) {\n              throw responseError;\n            } else if (response) {\n              return response;\n            } else {\n              throw new Error(\"Maximum retries reached with no response or error to throw\");\n            }\n          }\n\n          logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n          strategiesLoop: for (const strategy of strategies) {\n            const strategyLogger = strategy.logger || retryPolicyLogger;\n            strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n            const modifiers = strategy.retry({\n              retryCount,\n              response,\n              responseError\n            });\n\n            if (modifiers.skipStrategy) {\n              strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n              continue strategiesLoop;\n            }\n\n            const {\n              errorToThrow,\n              retryAfterInMs,\n              redirectTo\n            } = modifiers;\n\n            if (errorToThrow) {\n              strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n              throw errorToThrow;\n            }\n\n            if (retryAfterInMs || retryAfterInMs === 0) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n              yield delay(retryAfterInMs, undefined, {\n                abortSignal: request.abortSignal\n              });\n              continue retryRequest;\n            }\n\n            if (redirectTo) {\n              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n              request.url = redirectTo;\n              continue retryRequest;\n            }\n          }\n\n          if (responseError) {\n            logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n            throw responseError;\n          }\n\n          if (response) {\n            logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n            return response;\n          } // If all the retries skip and there's no response,\n          // we're still in the retry loop, so a new request will be sent\n          // until `maxRetries` is reached.\n\n        }\n      })();\n    }\n\n  };\n}","map":{"version":3,"names":["delay","createClientLogger","AbortError","DEFAULT_RETRY_POLICY_COUNT","retryPolicyLogger","retryPolicyName","retryPolicy","strategies","options","maxRetries","logger","name","sendRequest","request","next","_a","_b","response","responseError","retryCount","retryRequest","undefined","info","requestId","e","error","abortSignal","aborted","abortError","Error","length","strategiesLoop","strategy","strategyLogger","modifiers","retry","skipStrategy","errorToThrow","retryAfterInMs","redirectTo","url"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {\n    const logger = options.logger || retryPolicyLogger;\n    return {\n        name: retryPolicyName,\n        async sendRequest(request, next) {\n            var _a, _b;\n            let response;\n            let responseError;\n            let retryCount = -1;\n            // eslint-disable-next-line no-constant-condition\n            retryRequest: while (true) {\n                retryCount += 1;\n                response = undefined;\n                responseError = undefined;\n                try {\n                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n                    response = await next(request);\n                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n                }\n                catch (e) {\n                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n                    // RestErrors are valid targets for the retry strategies.\n                    // If none of the retry strategies can work with them, they will be thrown later in this policy.\n                    // If the received error is not a RestError, it is immediately thrown.\n                    responseError = e;\n                    if (!e || responseError.name !== \"RestError\") {\n                        throw e;\n                    }\n                    response = responseError.response;\n                }\n                if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                    logger.error(`Retry ${retryCount}: Request aborted.`);\n                    const abortError = new AbortError();\n                    throw abortError;\n                }\n                if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {\n                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);\n                    if (responseError) {\n                        throw responseError;\n                    }\n                    else if (response) {\n                        return response;\n                    }\n                    else {\n                        throw new Error(\"Maximum retries reached with no response or error to throw\");\n                    }\n                }\n                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n                strategiesLoop: for (const strategy of strategies) {\n                    const strategyLogger = strategy.logger || retryPolicyLogger;\n                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n                    const modifiers = strategy.retry({\n                        retryCount,\n                        response,\n                        responseError,\n                    });\n                    if (modifiers.skipStrategy) {\n                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n                        continue strategiesLoop;\n                    }\n                    const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n                    if (errorToThrow) {\n                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);\n                        throw errorToThrow;\n                    }\n                    if (retryAfterInMs || retryAfterInMs === 0) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);\n                        await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n                        continue retryRequest;\n                    }\n                    if (redirectTo) {\n                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);\n                        request.url = redirectTo;\n                        continue retryRequest;\n                    }\n                }\n                if (responseError) {\n                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);\n                    throw responseError;\n                }\n                if (response) {\n                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);\n                    return response;\n                }\n                // If all the retries skip and there's no response,\n                // we're still in the retry loop, so a new request will be sent\n                // until `maxRetries` is reached.\n            }\n        },\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}