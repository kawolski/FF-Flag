{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getInstrumenter } from \"./instrumenter\";\nimport { knownContextKeys } from \"./tracingContext\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\n\nexport function createTracingClient(options) {\n  const {\n    namespace,\n    packageName,\n    packageVersion\n  } = options;\n\n  function startSpan(name, operationOptions, spanOptions) {\n    var _a;\n\n    const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), {\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext\n    }));\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions = Object.assign({}, operationOptions, {\n      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), {\n        tracingContext\n      })\n    });\n    return {\n      span,\n      updatedOptions\n    };\n  }\n\n  function withSpan(_x, _x2, _x3, _x4) {\n    return _withSpan.apply(this, arguments);\n  }\n\n  function _withSpan() {\n    _withSpan = _asyncToGenerator(function* (name, operationOptions, callback, spanOptions) {\n      const {\n        span,\n        updatedOptions\n      } = startSpan(name, operationOptions, spanOptions);\n\n      try {\n        const result = yield withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n        span.setStatus({\n          status: \"success\"\n        });\n        return result;\n      } catch (err) {\n        span.setStatus({\n          status: \"error\",\n          error: err\n        });\n        throw err;\n      } finally {\n        span.end();\n      }\n    });\n    return _withSpan.apply(this, arguments);\n  }\n\n  function withContext(context, callback, ...callbackArgs) {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n\n\n  function parseTraceparentHeader(traceparentHeader) {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n\n\n  function createRequestHeaders(tracingContext) {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders\n  };\n}","map":{"version":3,"names":["getInstrumenter","knownContextKeys","createTracingClient","options","namespace","packageName","packageVersion","startSpan","name","operationOptions","spanOptions","_a","startSpanResult","Object","assign","tracingContext","tracingOptions","span","getValue","setValue","setAttribute","updatedOptions","withSpan","callback","result","withContext","Promise","resolve","setStatus","status","err","error","end","context","callbackArgs","parseTraceparentHeader","traceparentHeader","createRequestHeaders"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getInstrumenter } from \"./instrumenter\";\nimport { knownContextKeys } from \"./tracingContext\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options) {\n    const { namespace, packageName, packageVersion } = options;\n    function startSpan(name, operationOptions, spanOptions) {\n        var _a;\n        const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName: packageName, packageVersion: packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext }));\n        let tracingContext = startSpanResult.tracingContext;\n        const span = startSpanResult.span;\n        if (!tracingContext.getValue(knownContextKeys.namespace)) {\n            tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n        }\n        span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n        const updatedOptions = Object.assign({}, operationOptions, {\n            tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext }),\n        });\n        return {\n            span,\n            updatedOptions,\n        };\n    }\n    async function withSpan(name, operationOptions, callback, spanOptions) {\n        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n        try {\n            const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n            span.setStatus({ status: \"success\" });\n            return result;\n        }\n        catch (err) {\n            span.setStatus({ status: \"error\", error: err });\n            throw err;\n        }\n        finally {\n            span.end();\n        }\n    }\n    function withContext(context, callback, ...callbackArgs) {\n        return getInstrumenter().withContext(context, callback, ...callbackArgs);\n    }\n    /**\n     * Parses a traceparent header value into a span identifier.\n     *\n     * @param traceparentHeader - The traceparent header to parse.\n     * @returns An implementation-specific identifier for the span.\n     */\n    function parseTraceparentHeader(traceparentHeader) {\n        return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n    }\n    /**\n     * Creates a set of request headers to propagate tracing information to a backend.\n     *\n     * @param tracingContext - The context containing the span to serialize.\n     * @returns The set of headers to add to a request.\n     */\n    function createRequestHeaders(tracingContext) {\n        return getInstrumenter().createRequestHeaders(tracingContext);\n    }\n    return {\n        startSpan,\n        withSpan,\n        withContext,\n        parseTraceparentHeader,\n        createRequestHeaders,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}