{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_CHARKEY } from \"./interfaces\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\n\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\n\nexport function deserializationPolicy(options = {}) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions = {\n    xml: {\n      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY\n    }\n  };\n  return {\n    name: deserializationPolicyName,\n\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        const response = yield next(request);\n        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n      })();\n    }\n\n  };\n}\n\nfunction getOperationResponseMap(parsedResponse) {\n  let result;\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n\n  if (operationSpec) {\n    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse) {\n  const request = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n  let result;\n\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n\n  return result;\n}\n\nfunction deserializeResponseBody(_x, _x2, _x3, _x4, _x5) {\n  return _deserializeResponseBody.apply(this, arguments);\n}\n\nfunction _deserializeResponseBody() {\n  _deserializeResponseBody = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = yield parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n\n    if (!shouldDeserializeResponse(parsedResponse)) {\n      return parsedResponse;\n    }\n\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n\n    if (!operationSpec || !operationSpec.responses) {\n      return parsedResponse;\n    }\n\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const {\n      error,\n      shouldReturnResponse\n    } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n\n    if (error) {\n      throw error;\n    } else if (shouldReturnResponse) {\n      return parsedResponse;\n    } // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n\n\n    if (responseSpec) {\n      if (responseSpec.bodyMapper) {\n        let valueToDeserialize = parsedResponse.parsedBody;\n\n        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = typeof valueToDeserialize === \"object\" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];\n        }\n\n        try {\n          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n        } catch (deserializeError) {\n          const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse\n          });\n          throw restError;\n        }\n      } else if (operationSpec.httpMethod === \"HEAD\") {\n        // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n      }\n\n      if (responseSpec.headersMapper) {\n        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", {\n          xml: {},\n          ignoreUnknownProperties: true\n        });\n      }\n    }\n\n    return parsedResponse;\n  });\n  return _deserializeResponseBody.apply(this, arguments);\n}\n\nfunction isOperationSpecEmpty(operationSpec) {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\";\n}\n\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n  var _a;\n\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;\n\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return {\n          error: null,\n          shouldReturnResponse: false\n        };\n      }\n    } else {\n      return {\n        error: null,\n        shouldReturnResponse: false\n      };\n    }\n  }\n\n  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n  const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse\n  }); // If the item failed but there's no error spec or default spec to deserialize the error,\n  // we should fail so we just throw the parsed response\n\n  if (!errorResponseSpec) {\n    throw error;\n  }\n\n  const defaultBodyMapper = errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec.headersMapper;\n\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n\n      if (defaultBodyMapper) {\n        let valueToDeserialize = parsedBody;\n\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n\n        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n      }\n\n      const internalError = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n\n      if (defaultBodyMapper) {\n        error.response.parsedBody = deserializedError;\n      }\n    } // If error response has headers, try to deserialize it using default header mapper\n\n\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n    }\n  } catch (defaultError) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n\n  return {\n    error,\n    shouldReturnResponse: false\n  };\n}\n\nfunction parse(_x6, _x7, _x8, _x9, _x10) {\n  return _parse.apply(this, arguments);\n}\n\nfunction _parse() {\n  _parse = _asyncToGenerator(function* (jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {\n      const text = operationResponse.bodyAsText;\n      const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n      const contentComponents = !contentType ? [] : contentType.split(\";\").map(component => component.toLowerCase());\n\n      try {\n        if (contentComponents.length === 0 || contentComponents.some(component => jsonContentTypes.indexOf(component) !== -1)) {\n          operationResponse.parsedBody = JSON.parse(text);\n          return operationResponse;\n        } else if (contentComponents.some(component => xmlContentTypes.indexOf(component) !== -1)) {\n          if (!parseXML) {\n            throw new Error(\"Parsing XML not supported.\");\n          }\n\n          const body = yield parseXML(text, opts.xml);\n          operationResponse.parsedBody = body;\n          return operationResponse;\n        }\n      } catch (err) {\n        const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n        const errCode = err.code || RestError.PARSE_ERROR;\n        const e = new RestError(msg, {\n          code: errCode,\n          statusCode: operationResponse.status,\n          request: operationResponse.request,\n          response: operationResponse\n        });\n        throw e;\n      }\n    }\n\n    return operationResponse;\n  });\n  return _parse.apply(this, arguments);\n}","map":{"version":3,"names":["XML_CHARKEY","RestError","MapperTypeNames","getOperationRequestInfo","defaultJsonContentTypes","defaultXmlContentTypes","deserializationPolicyName","deserializationPolicy","options","_a","_b","_c","_d","_e","_f","_g","jsonContentTypes","expectedContentTypes","json","xmlContentTypes","xml","parseXML","serializerOptions","updatedOptions","rootName","includeRoot","xmlCharKey","name","sendRequest","request","next","response","deserializeResponseBody","getOperationResponseMap","parsedResponse","result","operationInfo","operationSpec","operationResponseGetter","responses","status","shouldDeserializeResponse","shouldDeserialize","undefined","parse","responseSpec","error","shouldReturnResponse","handleErrorResponse","bodyMapper","valueToDeserialize","parsedBody","isXML","type","Sequence","xmlElementName","serializer","deserialize","deserializeError","restError","bodyAsText","statusCode","httpMethod","headersMapper","parsedHeaders","headers","toJSON","ignoreUnknownProperties","isOperationSpecEmpty","expectedStatusCodes","Object","keys","length","isSuccessByStatus","isExpectedStatusCode","isError","errorResponseSpec","default","initialErrorMessage","streamResponseStatusCodes","has","defaultBodyMapper","defaultHeadersMapper","deserializedError","elementName","internalError","code","message","defaultError","operationResponse","opts","text","contentType","get","contentComponents","split","map","component","toLowerCase","some","indexOf","JSON","Error","body","err","msg","errCode","PARSE_ERROR","e"],"sources":["C:/Users/prash/source/repos/FF-Flag/FF-Flag/ClientApp/node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_CHARKEY, } from \"./interfaces\";\nimport { RestError, } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options = {}) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n    const parseXML = options.parseXML;\n    const serializerOptions = options.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY,\n        },\n    };\n    return {\n        name: deserializationPolicyName,\n        async sendRequest(request, next) {\n            const response = await next(request);\n            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n        },\n    };\n}\nfunction getOperationResponseMap(parsedResponse) {\n    let result;\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (operationSpec) {\n        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n            result = operationSpec.responses[parsedResponse.status];\n        }\n        else {\n            result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n        }\n    }\n    return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n    let result;\n    if (shouldDeserialize === undefined) {\n        result = true;\n    }\n    else if (typeof shouldDeserialize === \"boolean\") {\n        result = shouldDeserialize;\n    }\n    else {\n        result = shouldDeserialize(parsedResponse);\n    }\n    return result;\n}\nasync function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n    if (!shouldDeserializeResponse(parsedResponse)) {\n        return parsedResponse;\n    }\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (!operationSpec || !operationSpec.responses) {\n        return parsedResponse;\n    }\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n    if (error) {\n        throw error;\n    }\n    else if (shouldReturnResponse) {\n        return parsedResponse;\n    }\n    // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n    if (responseSpec) {\n        if (responseSpec.bodyMapper) {\n            let valueToDeserialize = parsedResponse.parsedBody;\n            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n                valueToDeserialize =\n                    typeof valueToDeserialize === \"object\"\n                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]\n                        : [];\n            }\n            try {\n                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n            }\n            catch (deserializeError) {\n                const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n                    statusCode: parsedResponse.status,\n                    request: parsedResponse.request,\n                    response: parsedResponse,\n                });\n                throw restError;\n            }\n        }\n        else if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n        }\n        if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", { xml: {}, ignoreUnknownProperties: true });\n        }\n    }\n    return parsedResponse;\n}\nfunction isOperationSpecEmpty(operationSpec) {\n    const expectedStatusCodes = Object.keys(operationSpec.responses);\n    return (expectedStatusCodes.length === 0 ||\n        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\"));\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n    var _a;\n    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)\n        ? isSuccessByStatus\n        : !!responseSpec;\n    if (isExpectedStatusCode) {\n        if (responseSpec) {\n            if (!responseSpec.isError) {\n                return { error: null, shouldReturnResponse: false };\n            }\n        }\n        else {\n            return { error: null, shouldReturnResponse: false };\n        }\n    }\n    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status))\n        ? `Unexpected status code: ${parsedResponse.status}`\n        : parsedResponse.bodyAsText;\n    const error = new RestError(initialErrorMessage, {\n        statusCode: parsedResponse.status,\n        request: parsedResponse.request,\n        response: parsedResponse,\n    });\n    // If the item failed but there's no error spec or default spec to deserialize the error,\n    // we should fail so we just throw the parsed response\n    if (!errorResponseSpec) {\n        throw error;\n    }\n    const defaultBodyMapper = errorResponseSpec.bodyMapper;\n    const defaultHeadersMapper = errorResponseSpec.headersMapper;\n    try {\n        // If error response has a body, try to deserialize it using default body mapper.\n        // Then try to extract error code & message from it\n        if (parsedResponse.parsedBody) {\n            const parsedBody = parsedResponse.parsedBody;\n            let deserializedError;\n            if (defaultBodyMapper) {\n                let valueToDeserialize = parsedBody;\n                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n                    valueToDeserialize = [];\n                    const elementName = defaultBodyMapper.xmlElementName;\n                    if (typeof parsedBody === \"object\" && elementName) {\n                        valueToDeserialize = parsedBody[elementName];\n                    }\n                }\n                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n            }\n            const internalError = parsedBody.error || deserializedError || parsedBody;\n            error.code = internalError.code;\n            if (internalError.message) {\n                error.message = internalError.message;\n            }\n            if (defaultBodyMapper) {\n                error.response.parsedBody = deserializedError;\n            }\n        }\n        // If error response has headers, try to deserialize it using default header mapper\n        if (parsedResponse.headers && defaultHeadersMapper) {\n            error.response.parsedHeaders =\n                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n        }\n    }\n    catch (defaultError) {\n        error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n    }\n    return { error, shouldReturnResponse: false };\n}\nasync function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) &&\n        operationResponse.bodyAsText) {\n        const text = operationResponse.bodyAsText;\n        const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n        const contentComponents = !contentType\n            ? []\n            : contentType.split(\";\").map((component) => component.toLowerCase());\n        try {\n            if (contentComponents.length === 0 ||\n                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {\n                operationResponse.parsedBody = JSON.parse(text);\n                return operationResponse;\n            }\n            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n                if (!parseXML) {\n                    throw new Error(\"Parsing XML not supported.\");\n                }\n                const body = await parseXML(text, opts.xml);\n                operationResponse.parsedBody = body;\n                return operationResponse;\n            }\n        }\n        catch (err) {\n            const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n            const errCode = err.code || RestError.PARSE_ERROR;\n            const e = new RestError(msg, {\n                code: errCode,\n                statusCode: operationResponse.status,\n                request: operationResponse.request,\n                response: operationResponse,\n            });\n            throw e;\n        }\n    }\n    return operationResponse;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}